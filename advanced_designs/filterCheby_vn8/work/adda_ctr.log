KCPSM3 Assembler log file for program 'adda_ctr.psm'.
Generated by KCPSM3 version 1.30
Ken Chapman (Xilinx Ltd) 2005.
29May2009-11:40:40

 Addr Code

 000                             ;KCPSM3 Program - SPI Control of Amplifier and A/D converter and D/A on Spartan-3E Starter Kit.
 000                             ;
 000                             ;Modded by Theja (theja@mit.edu)
 000                             ;v n1: ADC and DAC being used simultaneously. Problem with level shifting and scaling.
 000                             ;
 000                             ;Original templates by
 000                             ;Ken Chapman - Xilinx Ltd
 000                             ;
 000                             ;Version v1.00 - 21th December 2005
 000                             ;
 000                             ;As well as the port connections vital to communication with the UART and the SPI
 000                             ;FLASH memory, there are additional port connections used to disable the other
 000                             ;devices sharing the SPI bus on the Starter Kit board. Although these could have been
 000                             ;controlled at the hardware level, they are included in this code to aid
 000                             ;future investigations of communication with the other SPI devices using PicoBlaze.
 000                             ;
 000                             ;
 000                             ;Port definitions
 000                             ;
 000                             ;
 000                             CONSTANT SPI_control_port, 08       ;SPI clock and chip selects
 000                             CONSTANT SPI_sck, 01                ;                  SCK - bit0
 000                             CONSTANT SPI_rom_cs, 02             ;    serial rom select - bit1
 000                             CONSTANT SPI_spare_control, 04      ;                spare - bit2
 000                             CONSTANT SPI_amp_cs, 08             ;     amplifier select - bit3
 000                             CONSTANT SPI_adc_conv, 10           ;          A/D convert - bit4
 000                             CONSTANT SPI_dac_cs, 20             ;           D/A select - bit5
 000                             CONSTANT SPI_amp_shdn, 40           ;       amplifier SHDN - bit6
 000                             CONSTANT SPI_dac_clr, 80            ;            D/A clear - bit7
 000                             ;
 000                             CONSTANT SPI_output_port, 04        ;SPI data output
 000                             CONSTANT SPI_sdo, 80                ;   SDO - bit7
 000                             ;
 000                             CONSTANT SPI_input_port, 01         ;SPI data input
 000                             CONSTANT SPI_sdi, 80                ;             SDI - bit7
 000                             CONSTANT SPI_amp_sdi, 40            ;   amplifier SDI - bit6
 000                             ;
 000                             ;
 000                             CONSTANT LED_port, 80               ;8 simple LEDs
 000                             CONSTANT LED0, 01                   ;     LED 0 - bit0
 000                             CONSTANT LED1, 02                   ;         1 - bit1
 000                             CONSTANT LED2, 04                   ;         2 - bit2
 000                             CONSTANT LED3, 08                   ;         3 - bit3
 000                             CONSTANT LED4, 10                   ;         4 - bit4
 000                             CONSTANT LED5, 20                   ;         5 - bit5
 000                             CONSTANT LED6, 40                   ;         6 - bit6
 000                             CONSTANT LED7, 80                   ;         7 - bit7
 000                             ;
 000                             ;
 000                             CONSTANT switch_port, 00            ;Read switches and press buttons
 000                             CONSTANT BTN_north, 01              ;  Buttons     North - bit0
 000                             CONSTANT BTN_east, 02               ;               East - bit1
 000                             CONSTANT BTN_south, 04              ;              South - bit2
 000                             CONSTANT BTN_west, 08               ;               West - bit3
 000                             CONSTANT switch0, 10                ;  Switches        0 - bit4
 000                             CONSTANT switch1, 20                ;                  1 - bit5
 000                             CONSTANT switch2, 40                ;                  2 - bit6
 000                             CONSTANT switch3, 80                ;                  3 - bit7
 000                             ;
 000                             ;
 000                             ;;;;;;;;;;;;;;;new input port added by theja
 000                             CONSTANT int_check_port, 11         ; read which interrupt occured.
 000                             CONSTANT int_is_cheby, 01           ; bit0 - Chebyshev interrupt occured.
 000                             ;;;;;;;;;;;;;;;new input port added by theja ends
 000                             ;
 000                             ;LCD interface ports
 000                             ;
 000                             ;The master enable signal is not used by the LCD display itself
 000                             ;but may be required to confirm that LCD communication is active.
 000                             ;This is required on the Spartan-3E Starter Kit if the StrataFLASH
 000                             ;is used because it shares the same data pins and conflicts must be avoided.
 000                             ;
 000                             CONSTANT LCD_output_port, 40        ;LCD character module output data and control
 000                             CONSTANT LCD_E, 01                  ;   active High Enable        E - bit0
 000                             CONSTANT LCD_RW, 02                 ;   Read=1 Write=0           RW - bit1
 000                             CONSTANT LCD_RS, 04                 ;   Instruction=0 Data=1     RS - bit2
 000                             CONSTANT LCD_drive, 08              ;   Master enable (active High) - bit3
 000                             CONSTANT LCD_DB4, 10                ;   4-bit              Data DB4 - bit4
 000                             CONSTANT LCD_DB5, 20                ;   interface          Data DB5 - bit5
 000                             CONSTANT LCD_DB6, 40                ;                      Data DB6 - bit6
 000                             CONSTANT LCD_DB7, 80                ;                      Data DB7 - bit7
 000                             ;
 000                             ;
 000                             CONSTANT LCD_input_port, 02         ;LCD character module input data
 000                             CONSTANT LCD_read_spare0, 01        ;    Spare bits               - bit0
 000                             CONSTANT LCD_read_spare1, 02        ;    are zero                 - bit1
 000                             CONSTANT LCD_read_spare2, 04        ;                             - bit2
 000                             CONSTANT LCD_read_spare3, 08        ;                             - bit3
 000                             CONSTANT LCD_read_DB4, 10           ;    4-bit           Data DB4 - bit4
 000                             CONSTANT LCD_read_DB5, 20           ;    interface       Data DB5 - bit5
 000                             CONSTANT LCD_read_DB6, 40           ;                    Data DB6 - bit6
 000                             CONSTANT LCD_read_DB7, 80           ;                    Data DB7 - bit7
 000                             ;
 000                             ;
 000                             ;
 000                             ;
 000                             ;Special Register usage
 000                             ;
 000                             ;
 000                             ;
 000                             ;Scratch Pad Memory Locations
 000                             ;
 000                             ;Values read from the A/D converter
 000                             ;
 000                             CONSTANT ADC0_lsb, 00               ;ADC Channel 0 value LS-Byte
 000                             CONSTANT ADC0_msb, 01               ;                    MS-Byte
 000                             ;
 000                             ;CONSTANT ADC1_lsb, 02               ;ADC Channel 1 value LS-Byte
 000                             ;CONSTANT ADC1_msb, 03               ;                    MS-Byte
 000                             ;
 000                             ;Amplifier gain settings.
 000                             ;
 000                             ;Stored value is the 4-bit code for gain setting
 000                             ;  Code  1   2   3    4     5    6     7
 000                             ;  Gain -1  -2  -5  -10   -20  -50  -100
 000                             CONSTANT amp_A_gain, 04             ;Amplifier A gain value
 000                             CONSTANT amp_B_gain, 05             ;Amplifier B gain value
 000                             ;
 000                             ;Sample counter used to give activity indication on LEDs
 000                             ;
 000                             ;CONSTANT sample_count, 06           ;8-bit counter LS-Byte. Theja: redundant.
 000                             ;
 000                             CONSTANT decimal0, 07               ;5 digit decimal value
 000                             CONSTANT decimal1, 08
 000                             CONSTANT decimal2, 09
 000                             CONSTANT decimal3, 0A
 000                             CONSTANT decimal4, 0B
 000                             ;
 000                             ;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;
 000                             ;Values to be written to the D/A converter
 000                             CONSTANT chan_A_lsb, 0C             ;Channel C value LS-Byte
 000                             CONSTANT chan_A_msb, 0E             ;                MS-Byte
 000                             ;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;
 000                             ;
 000                             ;
 000                             ;Useful data constants
 000                             ;
 000                             CONSTANT VREF_lsb, 72               ;Reference voltage in milli-volts
 000                             CONSTANT VREF_msb, 06               ;Nominal value 1.65v so value is 1650 (0672 hex)
 000                             ;
 000                             ;Constant to define a software delay of 1us. This must be adjusted to reflect the
 000                             ;clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
 000                             ;calculation highly predictable. The '6' in the following equation even allows for
 000                             ;'CALL delay_1us' instruction in the initiating code.
 000                             ;
 000                             ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
 000                             ;
 000                             ;Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
 000                             ;For clock rates below 10MHz the value of 1 must be used and the operation will
 000                             ;become lower than intended.
 000                             ;
 000                             CONSTANT delay_1us_constant, 0B
 000                             ;
 000                             ;
 000                             ;
 000                             ;ASCII table
 000                             ;
 000                             CONSTANT character_a, 61
 000                             CONSTANT character_b, 62
 000                             CONSTANT character_c, 63
 000                             CONSTANT character_d, 64
 000                             CONSTANT character_e, 65
 000                             CONSTANT character_f, 66
 000                             CONSTANT character_g, 67
 000                             CONSTANT character_h, 68
 000                             CONSTANT character_i, 69
 000                             CONSTANT character_j, 6A
 000                             CONSTANT character_k, 6B
 000                             CONSTANT character_l, 6C
 000                             CONSTANT character_m, 6D
 000                             CONSTANT character_n, 6E
 000                             CONSTANT character_o, 6F
 000                             CONSTANT character_p, 70
 000                             CONSTANT character_q, 71
 000                             CONSTANT character_r, 72
 000                             CONSTANT character_s, 73
 000                             CONSTANT character_t, 74
 000                             CONSTANT character_u, 75
 000                             CONSTANT character_v, 76
 000                             CONSTANT character_w, 77
 000                             CONSTANT character_x, 78
 000                             CONSTANT character_y, 79
 000                             CONSTANT character_z, 7A
 000                             CONSTANT character_A, 41
 000                             CONSTANT character_B, 42
 000                             CONSTANT character_C, 43
 000                             CONSTANT character_D, 44
 000                             CONSTANT character_E, 45
 000                             CONSTANT character_F, 46
 000                             CONSTANT character_G, 47
 000                             CONSTANT character_H, 48
 000                             CONSTANT character_I, 49
 000                             CONSTANT character_J, 4A
 000                             CONSTANT character_K, 4B
 000                             CONSTANT character_L, 4C
 000                             CONSTANT character_M, 4D
 000                             CONSTANT character_N, 4E
 000                             CONSTANT character_O, 4F
 000                             CONSTANT character_P, 50
 000                             CONSTANT character_Q, 51
 000                             CONSTANT character_R, 52
 000                             CONSTANT character_S, 53
 000                             CONSTANT character_T, 54
 000                             CONSTANT character_U, 55
 000                             CONSTANT character_V, 56
 000                             CONSTANT character_W, 57
 000                             CONSTANT character_X, 58
 000                             CONSTANT character_Y, 59
 000                             CONSTANT character_Z, 5A
 000                             CONSTANT character_0, 30
 000                             CONSTANT character_1, 31
 000                             CONSTANT character_2, 32
 000                             CONSTANT character_3, 33
 000                             CONSTANT character_4, 34
 000                             CONSTANT character_5, 35
 000                             CONSTANT character_6, 36
 000                             CONSTANT character_7, 37
 000                             CONSTANT character_8, 38
 000                             CONSTANT character_9, 39
 000                             CONSTANT character_colon, 3A
 000                             CONSTANT character_stop, 2E
 000                             CONSTANT character_semi_colon, 3B
 000                             CONSTANT character_minus, 2D
 000                             CONSTANT character_divide, 2F       ;'/'
 000                             CONSTANT character_plus, 2B
 000                             CONSTANT character_comma, 2C
 000                             CONSTANT character_less_than, 3C
 000                             CONSTANT character_greater_than, 3E
 000                             CONSTANT character_equals, 3D
 000                             CONSTANT character_space, 20
 000                             CONSTANT character_CR, 0D           ;carriage return
 000                             CONSTANT character_question, 3F     ;'?'
 000                             CONSTANT character_dollar, 24
 000                             CONSTANT character_exclaim, 21      ;'!'
 000                             CONSTANT character_BS, 08           ;Back Space command character
 000                             ;
 000                             ;
 000                             ;
 000                             ;
 000                             ;
 000                             ;
 000                             ;Initialise the system
 000                             ;
 000                             ;
 000  300FB          cold_start: CALL SPI_init[0FB]                  ;initialise SPI bus ports
 001  301F4                      CALL LCD_reset[1F4]                 ;initialise LCD display
 002                             ;
 002                             ;;;;;;;;Write some message to LCD display
 002  00525                      LOAD s5, 25                         ;Line 2 position 5; in hex actually.
 003  3020A                      CALL LCD_cursor[20A]
 004  3016B                      CALL disp_Filter[16B]               ; could display your name too.
 005  301AC                      CALL delay_1s[1AC]                  ;wait 1 second
 006  30205                      CALL LCD_clear[205]                 ;Clear display
 007                             ;;Done writing some message to LCD display
 007                             ;
 007                             ;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;
 007  00000                      LOAD s0, 00
 008  2E00C                      STORE s0, chan_A_lsb[0C]            ;clear all internal D/A values
 009  2E00E                      STORE s0, chan_A_msb[0E]            ;clear all internal D/A values
 00A  30152                      CALL dac_reset[152]                 ;reset D/A converter on all channels
 00B                             ;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;
 00B                             ;
 00B                             ;;;;;;;;;;;Set a gain value for the ADC
 00B  00001                      LOAD s0, 01                         ;set initial amplifier gain to 1 on both channels
 00C  2E004                      STORE s0, amp_A_gain[04]            ;see encoding above. 01 in hex represents a gain of -1.
 00D  2E005                      STORE s0, amp_B_gain[05]
 00E  34072                      JUMP new_gain_set[072]              ;set, display the initial gain and enable interrupts
 00F                             ;;Done Setting a gain value for the ADC
 00F                             ;
 00F                             ;
 00F                             ;The main body
 00F                             ;of the program waits for an interrupt to occur. The interrupt updates all four
 00F                             ;analogue outputs with values stored in scratch pad memory. This takes approximately
 00F                             ;58us of the 125us available between interrupts. The main program then prepares
 00F                             ;new values for the analogue outputs (in less than 67us) before waiting for the
 00F                             ;next interrupt.
 00F                             ;
 00F                             ;
 00F  00FFF          warm_start: LOAD sF, FF                         ;flag set and wait for interrupt to be serviced
 010  3C001                      ENABLE INTERRUPT                    ;normal operation
 011                             ;
 011  14FFF            wait_int: COMPARE sF, FF                      ;wait for interrupt
 012  35011                      JUMP Z, wait_int[011]               ;interrupt clears the flag
 013                             ;
 013                             ;Convert A/D channel 0 value to decimal voltage
 013                             ;
 013                             ;The 14-bit signed value from the A/D (sign extended to 16-bits)
 013                             ;relates to a voltage in the range -1.25v to +1.25v at the input
 013                             ;to the A/D converter relative to the 1.65v mid-rail reference point.
 013                             ;
 013                             ;The 14-bit value can be translated into the -1.25v to +1.25v using the
 013                             ;simple equation...
 013                             ;
 013                             ;   ADin = AD_value x 1.25/8192  ... .. btw; 8192 means 2^13; 14 bit 2's complement
 013                             ;
 013                             ;It is possible to scale the AD_value by 1.25/8192 using a fixed point
 013                             ;representation.
 013                             ;
 013                             ;However, it is also possible to scale it by another factor at the
 013                             ;same time which nicely converts to a binary value which is readily
 013                             ;converted to decimal. This can be achieved by example...
 013                             ;
 013                             ;For an input to the A/D converter of +1.25v relative to the reference,
 013                             ;the A/D will output the maximum conversion of 1FFF (+8191).
 013                             ;
 013                             ;In this case we would like to have the result value +1.250v which can be represented
 013                             ;by the integer value +1250 with appropiate positioning of the decimal point.
 013                             ;The constant to achieve this conversion is +1250/8191=+0.152606...
 013                             ;Also a number requiring fixed point representation but how many bits to use?
 013                             ;
 013                             ;The way to resolve this is to realise that a multiplication will be
 013                             ;performed and it would be nice if the +1250 result ended up in a register pair.
 013                             ;So if we perform a 16x16-bit multiplication such that the upper 16-bits of
 013                             ;the 32-bit result is the required value, then everything will resolve itself.
 013                             ;
 013                             ;Hence the constant required is actually (1250x(2^16))/8191=+10001 (2711 hex).
 013                             ;
 013                             ;Using the example 1FFF x 2711 = 04E1F8EF
 013                             ;   of which the upper 16-bits = 04E1 (+1249 decimal)
 013                             ;
 013                             ;Likewise the other limit case is E000 x 2711 = FB1DE000
 013                             ;   of which the upper 16-bits = FB1D (-1251 decimal)
 013                             ;
 013                             ;The values can be made perfect by rounding before truncation
 013                             ;
 013                             ;
 013                             ;;;;;;;;;;;;;; new branching logic added by theja
 013  04011                      INPUT s0, int_check_port[11]
 014                             ;
 014                             ;
 014                             ;compare the input word (8 bit) with 00hex, if this is equal, then
 014                             ; the interrupt was of the chebyshev type so continue with the processing below
 014                             ; if this was of the equidistant type, only do the reading from verilog.
 014                             ; here redundantly adc sampling happens, but we don't use that sample value.
 014  14000                      COMPARE s0, 00
 015  3542E                      JUMP NZ, Only_Equidistant[02E]
 016                             ;
 016                             ;
 016                             ;
 016                             ;
 016  2C880                      OUTPUT s8, LED_port[80]
 017  2C980                      OUTPUT s9, LED_port[80]             ;theja: sending to the wrapper verilog IMPORTANT
 018                             ; sending is done only in the chebyshev interrupt case.
 018                             ;
 018                             ;
 018                             ;
 018  3019D                      CALL delay_40us[19D]                ; is the 30 cycle slowdown being taken care of?
 019                             ;
 019                             ;
 019                             ;
 019                             ;;;;;;;;;;;;;; new branching logic added by theja ends
 019                             ;
 019                             ;
 019                             ;
 019                             ;
 019  06200                      FETCH s2, ADC0_lsb[00]              ;Read A/D channel 0 value
 01A  06301                      FETCH s3, ADC0_msb[01]
 01B  00011                      LOAD s0, 11                         ;scaling value for input to A/D converter
 01C  00127                      LOAD s1, 27
 01D  300C0                      CALL mult_16x16s[0C0]               ;[s7,s6,s5,s4]=[s3,s2]x[s1,s0]
 01E  20506                      SL0 s5                              ;round value before truncation
 01F  1A600                      ADDCY s6, 00
 020  1A700                      ADDCY s7, 00
 021                             ;
 021                             ;The register pair [s7,s6] now holds the binary value
 021                             ;representing the input level to the A/D converter in milli-volts.
 021                             ;The code for displaying this on the LCD is removed. In case you want to do this:
 021                             ;1. Negative values need to be converted to signed magnitude for display.
 021                             ;2. Use bcd conversion routine.
 021                             ;
 021                             ;The same fundamental technique can be used to convert the 14-bit
 021                             ;A/D value into the level at the VINA input except that two more factors
 021                             ;must be considered. VINA is the actual input voltage (not between +-1.25v)
 021                             ;
 021                             ;The first is that the amplifier inverts and has gain. Therefore the
 021                             ;VINA input level is opposite polarity and is a deviation
 021                             ;from the mid rail 1.65v reference.
 021                             ;Secondly, to display the actual voltage level at the VINA terminal
 021                             ;the 1.65v offset must be added.
 021                             ;
 021                             ;The voltage at the VINA input is therefore...
 021                             ;
 021                             ;   VINA = [AD_value x (1.25/(8192))]+1.65
 021                             ;
 021                             ;Following the same methodology as for the A/D value, it means that there
 021                             ;is a set of scaling factors to deal with the negative gain values.
 021                             ;
 021                             ; K = (+1250 x (2^16)) / (8191 x G)
 021                             ;
 021                             ;        G             K     (K Hex)
 021                             ;       -1          -10001   (D8EF)
 021                             ;
 021  06200                      FETCH s2, ADC0_lsb[00]              ;Read A/D channel 0 value
 022  06301                      FETCH s3, ADC0_msb[01]
 023  06404                      FETCH s4, amp_A_gain[04]            ;read A gain and select appropiate gain setting
 024  000EF                      LOAD s0, EF                         ;scaling value for amplifier gain of -1
 025  001D8                      LOAD s1, D8
 026  300C0                      CALL mult_16x16s[0C0]               ;[s7,s6,s5,s4]=[s3,s2]x[s1,s0]
 027  20506                      SL0 s5                              ;round value before truncation
 028  1A600                      ADDCY s6, 00
 029  1A700                      ADDCY s7, 00
 02A  18672                      ADD s6, VREF_lsb[72]                ;add 1.65v offset represented at 1650 (0672 hex)
 02B  1A706                      ADDCY s7, VREF_msb[06]
 02C                             ;
 02C                             ;The register pair [s7,s6] now holds the binary value
 02C                             ;representing the VINA input level in milli-volts.
 02C                             ;This must be a positive value due to the offset of 1.65v
 02C                             ;being greater than the maximum relative range of -1.25v to +1.25v.
 02C                             ;
 02C                             ;If the A/D value is maximum negative (E000) or maximum positive (1FFF)
 02C                             ;then an indication of the actual value being applied being greater or
 02C                             ;less than that computed will be made.
 02C                             ;
 02C                             ;FETCH s2, ADC0_lsb                  ;Read A/D channel 0 value
 02C                             ;FETCH s3, ADC0_msb
 02C                             ;;;;;;;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;;;;
 02C                             ;
 02C                             ;
 02C                             ;
 02C                             ;
 02C  00C00                      LOAD sC, 00                         ;channel A IMPORTANT INFORMATION ABOUT DAC CHANNEL
 02D  3402F                      JUMP Skip_Only_Eq[02F]
 02E  00C01    Only_Equidistant: LOAD sC, 01                         ;channel B IMPORTANT INFORMATION ABOUT DAC CHANNEL
 02F                             ;The D/A converter has 4 channels. Specify which channel is to be set using
 02F                             ;register sC as follows....
 02F                             ;   sC     Channel                 Nominal Voltage Range
 02F                             ;   00        A                       0 to 3.30v (or VREFAB)
 02F                             ;   01        B                       0 to 3.30v (or VREFAB)
 02F                             ;   02        C                       0 to 2.50v (or VREFCD)
 02F                             ;   03        D                       0 to 2.50v (or VREFCD)
 02F                             ;   0F        All channels            various as above.
 02F  04300        Skip_Only_Eq: INPUT s3, switch_port[00]
 030  04200                      INPUT s2, switch_port[00]
 031  20306                      SL0 s3
 032  20200                      SLA s2
 033  20306                      SL0 s3
 034  20200                      SLA s2
 035  12280                      TEST s2, 80                         ;test sign bit of value
 036  3543E                      JUMP NZ, neg_value_DAC[03E]         ;if negative, then [s2,s3] is actually positive, so add ref.
 037                             ;        ;Gain = -1, remember
 037  00080                      LOAD s0, 80                         ; represents 2703 in decimal.
 038  00100                      LOAD s1, 00
 039  1D130                      SUB s1, s3
 03A  1F020                      SUBCY s0, s2
 03B  2E00E                      STORE s0, chan_A_msb[0E]            ;store value for D/A output
 03C  2E10C                      STORE s1, chan_A_lsb[0C]
 03D  34048                      JUMP dac_re_adc_value[048]
 03E  0E3FF       neg_value_DAC: XOR s3, FF                          ;take the 2's complement.
 03F  0E2FF                      XOR s2, FF
 040  18301                      ADD s3, 01
 041  1A200                      ADDCY s2, 00
 042                             ;AND s2, 03      ; the first 6 bits should be zero??
 042  00080                      LOAD s0, 80
 043  00100                      LOAD s1, 00
 044  19130                      ADD s1, s3
 045  1B020                      ADDCY s0, s2
 046  2E00E                      STORE s0, chan_A_msb[0E]            ;store value for D/A output
 047  2E10C                      STORE s1, chan_A_lsb[0C]
 048                             ;there was the channel selection register setting over here (below label)... LOAD sC,00
 048  06B0E    dac_re_adc_value: FETCH sB, chan_A_msb[0E]            ;12-bit value, ;from some reg where adc val is stored
 049  06A0C                      FETCH sA, chan_A_lsb[0C]            ;2 bytes
 04A                             ;LOAD sB, 80
 04A                             ;LOAD sA, 00
 04A  20B0E                      SR0 sB                              ; shift 12-bit value right 4 places
 04B  20A08                      SRA sA
 04C  20B0E                      SR0 sB
 04D  20A08                      SRA sA
 04E  20B0E                      SR0 sB
 04F  20A08                      SRA sA
 050  20B0E                      SR0 sB
 051  20A08                      SRA sA
 052  30136                      CALL set_dac[136]                   ;writing to the channel part
 053                             ;;;;;;;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;;;;
 053  3400F                      JUMP warm_start[00F]
 054                             ;
 054                             ;
 054                             ;**************************************************************************************
 054                             ;Display voltage level at in the form X.XXX on the LCD at current cursor position
 054                             ;**************************************************************************************
 054                             ;
 054                             ;Value to be displayed must be unsigned (positive) in the
 054                             ;[s7,s6] register pair. Only the lower 4 digits are displayed.
 054                             ;
 054  300DE          disp_volts: CALL integer16_to_BCD[0DE]          ;convert [s7,s6] to BCD in scratch pad memory
 055  0650A                      FETCH s5, decimal3[0A]
 056  18530                      ADD s5, 30                          ;convert to ASCII
 057  301CA                      CALL LCD_write_data[1CA]
 058  0052E                      LOAD s5, character_stop[2E]
 059  301CA                      CALL LCD_write_data[1CA]
 05A  06509                      FETCH s5, decimal2[09]
 05B  18530                      ADD s5, 30                          ;convert to ASCII
 05C  301CA                      CALL LCD_write_data[1CA]
 05D  06508                      FETCH s5, decimal1[08]
 05E  18530                      ADD s5, 30                          ;convert to ASCII
 05F  301CA                      CALL LCD_write_data[1CA]
 060  06507                      FETCH s5, decimal0[07]
 061  18530                      ADD s5, 30                          ;convert to ASCII
 062  301CA                      CALL LCD_write_data[1CA]
 063  00520                      LOAD s5, character_space[20]        ;ensure next position is cleared
 064  301CA                      CALL LCD_write_data[1CA]
 065  2A000                      RETURN
 066                             ;
 066                             ;**************************************************************************************
 066                             ;Changing amplifier gain using press buttons
 066                             ;**************************************************************************************
 066                             ;
 066                             ;Possible gain values are
 066                             ;   Gain   Amplifier
 066                             ;            code
 066                             ;    -1        1
 066                             ;    -2        2
 066                             ;    -5        3
 066                             ;   -10        4
 066                             ;   -20        5
 066                             ;   -50        6
 066                             ;  -100        7
 066                             ;
 066  3C000       gain_increase: DISABLE INTERRUPT                   ;stop normal operation
 067  06004                      FETCH s0, amp_A_gain[04]            ;read current gain
 068  18001                      ADD s0, 01
 069  14008                      COMPARE s0, 08                      ;test for too big
 06A  35472                      JUMP NZ, new_gain_set[072]
 06B  00007                      LOAD s0, 07                         ;maximum gain
 06C  34072                      JUMP new_gain_set[072]
 06D  3C000       gain_decrease: DISABLE INTERRUPT                   ;stop normal operation
 06E  06004                      FETCH s0, amp_A_gain[04]            ;read current gain
 06F  1C001                      SUB s0, 01
 070  35472                      JUMP NZ, new_gain_set[072]
 071  00001                      LOAD s0, 01                         ;minimum gain
 072  2E004        new_gain_set: STORE s0, amp_A_gain[04]            ;store new value
 073  06205                      FETCH s2, amp_B_gain[05]            ;form the amplifier control byte
 074  20206                      SL0 s2                              ;B amplifier set by upper 4 bits
 075  20206                      SL0 s2
 076  20206                      SL0 s2
 077  20206                      SL0 s2
 078  0D200                      OR s2, s0                           ;A amplifier set by lower
 079  300FE                      CALL set_amp[0FE]                   ;set SPI amplifier
 07A                             ;display gain setting on LCD
 07A  00510                      LOAD s5, 10                         ;Line 1 position 0
 07B  3020A                      CALL LCD_cursor[20A]
 07C  00547                      LOAD s5, character_G[47]
 07D  301CA                      CALL LCD_write_data[1CA]
 07E  0053D                      LOAD s5, character_equals[3D]
 07F  301CA                      CALL LCD_write_data[1CA]
 080  0052D                      LOAD s5, character_minus[2D]
 081  301CA                      CALL LCD_write_data[1CA]
 082  06004                      FETCH s0, amp_A_gain[04]            ;read A gain setting
 083  14001                      COMPARE s0, 01                      ;determine actual gain value
 084  3548C                      JUMP NZ, test_A2[08C]
 085  00531                      LOAD s5, character_1[31]            ;gain is -1
 086  301CA                      CALL LCD_write_data[1CA]
 087  00520                      LOAD s5, character_space[20]
 088  301CA                      CALL LCD_write_data[1CA]
 089  00520                      LOAD s5, character_space[20]
 08A  301CA                      CALL LCD_write_data[1CA]
 08B  340BF                      JUMP wait_no_press[0BF]
 08C  14002             test_A2: COMPARE s0, 02
 08D  35495                      JUMP NZ, test_A3[095]
 08E  00532                      LOAD s5, character_2[32]            ;gain is -2
 08F  301CA                      CALL LCD_write_data[1CA]
 090  00520                      LOAD s5, character_space[20]
 091  301CA                      CALL LCD_write_data[1CA]
 092  00520                      LOAD s5, character_space[20]
 093  301CA                      CALL LCD_write_data[1CA]
 094  340BF                      JUMP wait_no_press[0BF]
 095  14003             test_A3: COMPARE s0, 03
 096  3549E                      JUMP NZ, test_A4[09E]
 097  00535                      LOAD s5, character_5[35]            ;gain is -5
 098  301CA                      CALL LCD_write_data[1CA]
 099  00520                      LOAD s5, character_space[20]
 09A  301CA                      CALL LCD_write_data[1CA]
 09B  00520                      LOAD s5, character_space[20]
 09C  301CA                      CALL LCD_write_data[1CA]
 09D  340BF                      JUMP wait_no_press[0BF]
 09E  14004             test_A4: COMPARE s0, 04
 09F  354A7                      JUMP NZ, test_A5[0A7]
 0A0  00531                      LOAD s5, character_1[31]            ;gain is -10
 0A1  301CA                      CALL LCD_write_data[1CA]
 0A2  00530                      LOAD s5, character_0[30]
 0A3  301CA                      CALL LCD_write_data[1CA]
 0A4  00520                      LOAD s5, character_space[20]
 0A5  301CA                      CALL LCD_write_data[1CA]
 0A6  340BF                      JUMP wait_no_press[0BF]
 0A7  14005             test_A5: COMPARE s0, 05
 0A8  354B0                      JUMP NZ, test_A6[0B0]
 0A9  00532                      LOAD s5, character_2[32]            ;gain is -20
 0AA  301CA                      CALL LCD_write_data[1CA]
 0AB  00530                      LOAD s5, character_0[30]
 0AC  301CA                      CALL LCD_write_data[1CA]
 0AD  00520                      LOAD s5, character_space[20]
 0AE  301CA                      CALL LCD_write_data[1CA]
 0AF  340BF                      JUMP wait_no_press[0BF]
 0B0  14006             test_A6: COMPARE s0, 06
 0B1  354B9                      JUMP NZ, gain_A7[0B9]
 0B2  00535                      LOAD s5, character_5[35]            ;gain is -50
 0B3  301CA                      CALL LCD_write_data[1CA]
 0B4  00530                      LOAD s5, character_0[30]
 0B5  301CA                      CALL LCD_write_data[1CA]
 0B6  00520                      LOAD s5, character_space[20]
 0B7  301CA                      CALL LCD_write_data[1CA]
 0B8  340BF                      JUMP wait_no_press[0BF]
 0B9  00531             gain_A7: LOAD s5, character_1[31]            ;gain is -100
 0BA  301CA                      CALL LCD_write_data[1CA]
 0BB  00530                      LOAD s5, character_0[30]
 0BC  301CA                      CALL LCD_write_data[1CA]
 0BD  00530                      LOAD s5, character_0[30]
 0BE  301CA                      CALL LCD_write_data[1CA]
 0BF                             ;;wait_no_press: CALL delay_20ms                     ;delay to help avoid switch bounce
 0BF                             ;INPUT s0, switch_port               ;check for release of press buttons
 0BF                             ;TEST s0, 05                         ;north and south buttons
 0BF                             ;JUMP NZ, wait_no_press
 0BF  3400F       wait_no_press: JUMP warm_start[00F]
 0C0                             ;
 0C0                             ;**************************************************************************************
 0C0                             ;16-bit by 16-bit Signed multiplier
 0C0                             ;**************************************************************************************
 0C0                             ;
 0C0                             ;16 bit signed multiplication using shift and add technique.
 0C0                             ;The full precision 32-bit product is returned.
 0C0                             ;
 0C0                             ;The key to signed multiplication is to think of all bits of the second operand
 0C0                             ;[s1,s0] as being positive except for the most significant bit. This means that
 0C0                             ;the first operand is added to the result in all cases when there is a '1' in the
 0C0                             ;second operand except for the MSB case when the first operand is subtracted if there
 0C0                             ;is a '1'.
 0C0                             ;
 0C0                             ;[s7,s6,s5,s4]=[s3,s2]x[s1,s0]
 0C0                             ;
 0C0                             ;Registers used s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,sA
 0C0                             ;
 0C0  00700         mult_16x16s: LOAD s7, 00                         ;clear accumulator
 0C1  00600                      LOAD s6, 00
 0C2  00500                      LOAD s5, 00                         ;Set bit 14 to act as a bit shift counter
 0C3  00400                      LOAD s4, 00
 0C4  00800                      LOAD s8, 00                         ;sign extend [s3,s2] to form [s9,s8,s3,s2]
 0C5  12380                      TEST s3, 80                         ;test sign of first operand
 0C6  350C8                      JUMP Z, m16s_pos[0C8]
 0C7  008FF                      LOAD s8, FF
 0C8  01980            m16s_pos: LOAD s9, s8                         ;[s9,s8,s3,s2]=0000xxxx or FFFFxxxx as required
 0C9  00A0F                      LOAD sA, 0F                         ;15 positive shift and add operations to perform
 0CA  2010E           m16s_loop: SR0 s1                              ;shift right operand [s1,s0]
 0CB  20008                      SRA s0
 0CC  35CD1                      JUMP NC, m16s_noadd[0D1]            ;test for a '1'
 0CD  19420                      ADD s4, s2                          ;32-bit addition [s7,s6,s5,s4]=[s7,s6,s5,s4]+[s9,s8,s3,s2]
 0CE  1B530                      ADDCY s5, s3
 0CF  1B680                      ADDCY s6, s8
 0D0  1B790                      ADDCY s7, s9
 0D1  20206          m16s_noadd: SL0 s2                              ;multiply first operand by 2
 0D2  20300                      SLA s3
 0D3  20800                      SLA s8
 0D4  20900                      SLA s9
 0D5  1CA01                      SUB sA, 01
 0D6  354CA                      JUMP NZ, m16s_loop[0CA]             ;move to next unsigned bit
 0D7  12001                      TEST s0, 01                         ;test sign bit of operand [s1,s0]
 0D8  35CDD                      JUMP NC, m16s_nosub[0DD]
 0D9  1D420                      SUB s4, s2                          ;32-bit subtraction [s7,s6,s5,s4]=[s7,s6,s5,s4]-[s9,s8,s3,s2]
 0DA  1F530                      SUBCY s5, s3
 0DB  1F680                      SUBCY s6, s8
 0DC  1F790                      SUBCY s7, s9
 0DD  2A000          m16s_nosub: RETURN
 0DE                             ;
 0DE                             ;
 0DE                             ;
 0DE                             ;**************************************************************************************
 0DE                             ;16-bit positive integer to 5 digit decimal conversion
 0DE                             ;**************************************************************************************
 0DE                             ;
 0DE                             ;Convert the 16 bit value in register set [s7,s6]
 0DE                             ;into the BCD decimal equivalent located in the scratch pad memory
 0DE                             ;locations 'decimal0' to 'decimal4' which must be in ascending locations.
 0DE                             ;
 0DE                             ;Register set [s9,s8,s7,s6] are preserved.
 0DE                             ;
 0DE                             ;
 0DE                             ;Each digit is formed in turn starting with the least significant.
 0DE                             ;
 0DE                             ;Registers used s0,s1,s2,s3,s4,s5,s6,s7,s8
 0DE                             ;
 0DE  00005    integer16_to_BCD: LOAD s0, 05                         ;5 digits to be formed from value up to 65535
 0DF  00807                      LOAD s8, decimal0[07]               ;pointer for LS-Digit
 0E0  300E6     int_to_BCD_loop: CALL divide_16bit_by_10[0E6]        ;[s7,s6]=[s7,s6]/10  with remainder in s4
 0E1  2F480                      STORE s4, (s8)                      ;remainder becomes digit value
 0E2  18801                      ADD s8, 01                          ;move to next most significant digit
 0E3  1C001                      SUB s0, 01                          ;one less digit to compute
 0E4  354E0                      JUMP NZ, int_to_BCD_loop[0E0]
 0E5  2A000                      RETURN
 0E6                             ;
 0E6                             ;Divide 16-bit binary integer by 10
 0E6                             ;
 0E6                             ;The value to be divided is held in register set [s7,s6]
 0E6                             ;and this is where the result is returned to.
 0E6                             ;
 0E6                             ;At then end of the integer division the remainder in the range 0 to 9
 0E6                             ;will be in register s4.
 0E6                             ;
 0E6                             ;Registers used s1,s2,s3,s4,s5,s6,s7
 0E6                             ;Other registers are used but are preserved
 0E6                             ;
 0E6  01460  divide_16bit_by_10: LOAD s4, s6                         ;copy input value to [s5,s4]
 0E7  01570                      LOAD s5, s7
 0E8  00600                      LOAD s6, 00                         ;clear result
 0E9  00700                      LOAD s7, 00
 0EA  00200                      LOAD s2, 00                         ;initialise '10' value into msb's of set [s3,s2]
 0EB  003A0                      LOAD s3, A0
 0EC  0010D                      LOAD s1, 0D                         ;13 subtract and shift iterations to be performed
 0ED  1D420          div10_loop: SUB s4, s2                          ;perform 16-bit subtract [s5,s4]-[s3,s2]
 0EE  1F530                      SUBCY s5, s3
 0EF  358F2                      JUMP C, div10_restore[0F2]
 0F0  20607                      SL1 s6                              ;shift '1' into result because subtract was possible
 0F1  340F5                      JUMP div10_shifts[0F5]
 0F2  19420       div10_restore: ADD s4, s2                          ;perform 32-bit addition [s5,s4]+[s3,s2]
 0F3  1B530                      ADDCY s5, s3                        ;to restore value
 0F4  20606                      SL0 s6                              ;shift '0' into result because subtract was not possible
 0F5  20700        div10_shifts: SLA s7                              ;complete 16-bit shift left
 0F6  2030E                      SR0 s3                              ;divide '10' value by 2 (shift right 1 place)
 0F7  20208                      SRA s2
 0F8  1C101                      SUB s1, 01                          ;count iterations
 0F9  354ED                      JUMP NZ, div10_loop[0ED]
 0FA  2A000                      RETURN
 0FB                             ;
 0FB                             ;
 0FB                             ;**************************************************************************************
 0FB                             ;SPI communication routines for Spartan-3E Starter Kit
 0FB                             ;**************************************************************************************
 0FB                             ;
 0FB                             ;These routines will work with two output ports and one input port which should be
 0FB                             ;defined as follows using CONSTANT directives.
 0FB                             ;   (replace 'pp' with appropriate port address in each case)
 0FB                             ;In the list of CONSTANT directives, there are ports associated with all the SPI devices
 0FB                             ;provided on the board. Even if some devices are not used, it is vital that the remaining
 0FB                             ;devices are disabled. Leaving all signals connected and use of these routines will ensure
 0FB                             ;that all other devices are disabled when communicating with a particular device.
 0FB                             ;
 0FB                             ;
 0FB                             ;
 0FB                             ;CONSTANT SPI_control_port, pp       ;SPI clock and chip selects
 0FB                             ;CONSTANT SPI_sck, 01                ;                  SCK - bit0
 0FB                             ;CONSTANT SPI_rom_cs, 02             ;    serial rom select - bit1
 0FB                             ;CONSTANT SPI_spare_control, 04      ;                spare - bit2
 0FB                             ;CONSTANT SPI_amp_cs, 08             ;     amplifier select - bit3
 0FB                             ;CONSTANT SPI_adc_conv, 10           ;          A/D convert - bit4
 0FB                             ;CONSTANT SPI_dac_cs, 20             ;           D/A select - bit5
 0FB                             ;CONSTANT SPI_amp_shdn, 40           ;       amplifier SHDN - bit6
 0FB                             ;CONSTANT SPI_dac_clr, 80            ;            D/A clear - bit7
 0FB                             ;
 0FB                             ;CONSTANT SPI_output_port, pp        ;SPI data output
 0FB                             ;CONSTANT SPI_sdo, 80                ;   SDO - bit7
 0FB                             ;
 0FB                             ;CONSTANT SPI_input_port, pp         ;SPI data input
 0FB                             ;CONSTANT SPI_sdi, 80                ;             SDI - bit7
 0FB                             ;CONSTANT SPI_amp_sdi, 40            ;   amplifier SDI - bit6
 0FB                             ;
 0FB                             ;
 0FB                             ;
 0FB                             ;
 0FB                             ;Initialise SPI bus
 0FB                             ;
 0FB                             ;This routine should be used to initialise the SPI bus.
 0FB                             ;The SCK clock is made low.
 0FB                             ;Device selections are made inactive as follows
 0FB                             ;   SPI_sck      = 0      Clock is Low (required)
 0FB                             ;   SPI_rom_cs   = 1      Deselect ROM
 0FB                             ;   spare        = 1      spare control bit
 0FB                             ;   SPI_amp_cs   = 1      Deselect amplifier
 0FB                             ;   SPI_adc_conv = 0      A/D convert ready to apply positive pulse
 0FB                             ;   SPI_dac_cs   = 1      Deselect D/A
 0FB                             ;   SPI_amp_shdn = 0      Amplifier active and available
 0FB                             ;   SPI_dac_clr  = 1      D/A clear off
 0FB                             ;
 0FB  000AE            SPI_init: LOAD s0, AE                         ;normally AE
 0FC  2C008                      OUTPUT s0, SPI_control_port[08]
 0FD  2A000                      RETURN
 0FE                             ;
 0FE                             ;
 0FE                             ;
 0FE                             ;
 0FE                             ;**************************************************************************************
 0FE                             ;SPI communication routines for Programmable Amplifier
 0FE                             ;**************************************************************************************
 0FE                             ;
 0FE                             ;
 0FE                             ;Set the A and B channel gain of the Dual Amplifier (LTC6912-1).
 0FE                             ;
 0FE                             ;The gain value should be provided in the s2 register with the upper nibble
 0FE                             ;defining the gain for the B channel and lower nibble the gain for the A channel.
 0FE                             ; 0000 = 0 hex = Gain  0 with input hi-Z and output driving
 0FE                             ; 0001 = 1 hex = Gain -1
 0FE                             ; 0010 = 2 hex = Gain -2
 0FE                             ; 0011 = 3 hex = Gain -5
 0FE                             ; 0100 = 4 hex = Gain -10
 0FE                             ; 0101 = 5 hex = Gain -20
 0FE                             ; 0110 = 6 hex = Gain -50
 0FE                             ; 0111 = 7 hex = Gain -100
 0FE                             ; 1000 = 8 hex = software shutdown (power on default). Hi-Z output.
 0FE                             ;
 0FE                             ;On return, the s2, register will contain the response from the LTC6912-1 amplifier.
 0FE                             ;This will be the same format and indicate the previous setting of the amplifier.
 0FE                             ;The response is obtained from the dedicated AMP_SDI signal since the LTC6912 output
 0FE                             ;is always active and can not be on a shared SPI bus.
 0FE                             ;
 0FE  300FB             set_amp: CALL SPI_init[0FB]                  ;ensure known state of bus and s0 register
 0FF  0E008                      XOR s0, SPI_amp_cs[08]              ;select low on Amplifier chip select
 100  2C008                      OUTPUT s0, SPI_control_port[08]
 101  00108                      LOAD s1, 08                         ;8-bits to transmit and receive
 102  2C204    next_amp_SPI_bit: OUTPUT s2, SPI_output_port[04]      ;output data bit
 103  0E001                      XOR s0, SPI_sck[01]                 ;clock High (bit0)
 104  2C008                      OUTPUT s0, SPI_control_port[08]     ;drive clock High
 105  04301                      INPUT s3, SPI_input_port[01]        ;read input bit
 106  12340                      TEST s3, SPI_amp_sdi[40]            ;detect state of received bit
 107  20200                      SLA s2                              ;shift new data into result and move to next transmit bit
 108  0E001                      XOR s0, SPI_sck[01]                 ;clock Low (bit0)
 109  2C008                      OUTPUT s0, SPI_control_port[08]     ;drive clock Low
 10A  1C101                      SUB s1, 01                          ;count bits
 10B  35502                      JUMP NZ, next_amp_SPI_bit[102]      ;repeat until finished
 10C  0E008                      XOR s0, SPI_amp_cs[08]              ;deselect the amplifier
 10D  2C008                      OUTPUT s0, SPI_control_port[08]
 10E  2A000                      RETURN
 10F                             ;
 10F                             ;
 10F                             ;
 10F                             ;**************************************************************************************
 10F                             ;SPI communication routines for A/D Converter
 10F                             ;**************************************************************************************
 10F                             ;
 10F                             ;
 10F                             ;
 10F                             ;Sample A/D converter (LTC1407A-1) and return results.
 10F                             ;
 10F                             ;Note there is a latency of one read to obtain the value. Each read results in the
 10F                             ;the analogue inputs being sampled and converted but this value will only be transmitted
 10F                             ;during the next read and conversion cycle.
 10F                             ;
 10F                             ;The results are returned as follows.
 10F                             ;   Channel 0 in registers [s9,s8]
 10F                             ;   Channel 1 in registers [s7,s6]
 10F                             ;Where each is a 14-bit twos complement value sign extended to 16-bits.
 10F                             ;
 10F                             ;Each 14-bit value represents the analogue voltage in the range -1.25v to +1.25v
 10F                             ;relative to the reference voltage of 1.65v (3.3v/2). Hence the actual input voltage
 10F                             ;range is 0.4v to 2.9v. Since the input to the A/D is supplied via the programmable
 10F                             ;amplifier, the VINA and VINB inputs are inverted and may cover a smaller range if                       ;
 10F                             ;desired.
 10F                             ;
 10F                             ;Examples
 10F                             ;   VINA = 0.65v with gain=-1 means input to A/D = 2.65v
 10F                             ;      This is equivalent to +1.00v which is value (8192/1.25)*1 = 6553 (1999 hex)
 10F                             ;
 10F                             ;   VINA = 2.65v with gain=-1 means input to A/D = 0.65v
 10F                             ;      This is equivalent to -1.00v which is value (2048/1.25)*-1 = -6553 (E667 hex)
 10F                             ;
 10F                             ;
 10F                             ;Although the A/D converter claims to be an SPI device, it really
 10F                             ;does not conform to the normal specification of the 4-wire interface.
 10F                             ;
 10F                             ;Firstly the CONV signal is only pulsed High and does not behave like
 10F                             ;a normal active low select signal. Secondly, the communication is
 10F                             ;34 bits which does not fit a byte boundary, and thirdly, the data output
 10F                             ;to its SDO pin changes as a result of rising edges of SCK clock which
 10F                             ;is not the same as the falling edge used by other devices.
 10F                             ;
 10F  300FB            adc_read: CALL SPI_init[0FB]                  ;ensure known state of bus and s0 register
 110  0E010                      XOR s0, SPI_adc_conv[10]            ;Pulse AD-CONV High to take sample and start
 111  2C008                      OUTPUT s0, SPI_control_port[08]     ;  conversion and transmission of data.
 112  0E010                      XOR s0, SPI_adc_conv[10]            ;AD-CONV Low
 113  2C008                      OUTPUT s0, SPI_control_port[08]
 114  00122                      LOAD s1, 22                         ;34 clocks to read all data
 115  0E001        next_adc_bit: XOR s0, SPI_sck[01]                 ;clock High (bit0)
 116  2C008                      OUTPUT s0, SPI_control_port[08]     ;drive clock High
 117  0E001                      XOR s0, SPI_sck[01]                 ;clock Low (bit0)
 118  2C008                      OUTPUT s0, SPI_control_port[08]     ;drive clock Low
 119  04301                      INPUT s3, SPI_input_port[01]        ;read input bit
 11A  12380                      TEST s3, SPI_sdi[80]                ;detect state of received bit
 11B  20600                      SLA s6                              ;shift new data into result registers
 11C  20700                      SLA s7
 11D  20800                      SLA s8
 11E  20900                      SLA s9
 11F  1C101                      SUB s1, 01                          ;count bits
 120  35515                      JUMP NZ, next_adc_bit[115]          ;repeat until finished
 121  2090A                      SRX s9                              ;sign extend 14-bit result in [s9,s8]
 122  20808                      SRA s8
 123  2090A                      SRX s9
 124  20808                      SRA s8
 125  2070A                      SRX s7                              ;sign extend 14-bit result in [s7,s6]
 126  20608                      SRA s6
 127  2070A                      SRX s7
 128  20608                      SRA s6
 129  2A000                      RETURN
 12A                             ;
 12A                             ;
 12A                             ;;;;;;;;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;;;;;;;;
 12A                             ;;;;;;;;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;;;;;;;;
 12A                             ;;;;;;;;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;;;;;;;;
 12A                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 12A                             ;
 12A                             ;D/A related: Send and receive one byte to and from the SPI D/A converter.
 12A                             ;
 12A                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 12A                             ;The data supplied in register 's2' is transmitted to the SPI bus and
 12A                             ;at the same time the received byte is used to replace the value in 's2'.
 12A                             ;The SCK clock is generated by software and results in a communication rate of
 12A                             ;2.5Mbit/s with a 50MHz clock.
 12A                             ;
 12A                             ;Note that you must have previously selected the required device on the bus
 12A                             ;before attempting communication and you must subsequently deselect the device
 12A                             ;when appropriate.
 12A                             ;
 12A                             ;Entry to this routine assumes that register s0 defines the state of the SPI
 12A                             ;control signals including SCK which should be Low. The easiest way to achieve this is
 12A                             ;to use the SPI_init routine before calling this one for the first time.
 12A                             ;
 12A                             ;As a 'master' the signal sequence is as follows..
 12A                             ;   Transmit data bit on SDO line
 12A                             ;   Drive SCK transition from low to high
 12A                             ;   Receive data bit from SDI line (D/A transmits on previous falling edge)
 12A                             ;   Drive SCK transition from high to low.
 12A                             ;
 12A                             ;Important note
 12A                             ;   The received data bit must be captured some time before SCK goes low.
 12A                             ;   However the combination of relatively slow clock to output time of the
 12A                             ;   LTC2624 combined with the low drive strength of its SDO output means that
 12A                             ;   the received bit needs maximum time to settle. Therefore this routine
 12A                             ;   schedules the read as late as it can.
 12A                             ;
 12A  00108       SPI_dac_tx_rx: LOAD s1, 08                         ;8-bits to transmit and receive
 12B  2C204    next_SPI_dac_bit: OUTPUT s2, SPI_output_port[04]      ;output data bit ready to be used on rising edge
 12C  0E001                      XOR s0, SPI_sck[01]                 ;clock High (bit0)
 12D  2C008                      OUTPUT s0, SPI_control_port[08]     ;drive clock High
 12E  0E001                      XOR s0, SPI_sck[01]                 ;prepare clock Low (bit0)
 12F  04301                      INPUT s3, SPI_input_port[01]        ;read input bit
 130  12380                      TEST s3, SPI_sdi[80]                ;detect state of received bit
 131  20200                      SLA s2                              ;shift new data into result and move to next transmit bit
 132  2C008                      OUTPUT s0, SPI_control_port[08]     ;drive clock Low
 133  1C101                      SUB s1, 01                          ;count bits
 134  3552B                      JUMP NZ, next_SPI_dac_bit[12B]      ;repeat until finished
 135  2A000                      RETURN
 136                             ;
 136                             ;
 136                             ;
 136                             ;Set a voltage on one of the LTC2624 D/A converter outputs
 136                             ;
 136                             ;The D/A converter has 4 channels. Specify which channel is to be set using
 136                             ;register sC as follows....
 136                             ;   sC     Channel                 Nominal Voltage Range
 136                             ;   00        A                       0 to 3.30v (or VREFAB)
 136                             ;   01        B                       0 to 3.30v (or VREFAB)
 136                             ;   02        C                       0 to 2.50v (or VREFCD)
 136                             ;   03        D                       0 to 2.50v (or VREFCD)
 136                             ;   0F        All channels            various as above.
 136                             ;
 136                             ;The analogue level is a 12-bit value to be supplied in lower 12-bits of register
 136                             ;pair [sB,sA]. If this value is called 'k' and is in the range 0 to 4095 (000 to FFF)
 136                             ;then
 136                             ;      Vout = (k/4096) * VREFx
 136                             ;Hence it is not possible to reach the absolute level of the reference.
 136                             ;
 136                             ;Here are some useful values..
 136                             ;    Voltage    A or B    C or D
 136                             ;      0.0       000       000
 136                             ;      0.5       26D       333
 136                             ;      0.65      327               A/D reference -1.00v
 136                             ;      1.0       4D9       666
 136                             ;      1.5       746       99A
 136                             ;      1.65      800       A8F     converter reference = 3.3/2 = 1.65v
 136                             ;      2.0       9B2       CCD
 136                             ;      2.5       C1F       FFF
 136                             ;      2.65      CD9               A/D reference +1.00v
 136                             ;      3.0       E8C       n/a
 136                             ;      3.3       FFF       n/a
 136                             ;
 136                             ;Note that the full scale deflection of FFF will result in different output
 136                             ;voltages due to different reference voltages for each pair of channels.
 136                             ;
 136                             ;SPI communication with the DAC only requires a 24-bit word to be transmitted.
 136                             ;However, the device internally contains a 32-bit shift register. When writing
 136                             ;a command word, the previous contents are shifted out and can be observed by
 136                             ;the master (Spartan-3E in this case). If you do not use a 32-bit format, then
 136                             ;the read back is confusing. Hence this routine uses a 32-bit format by transmitting
 136                             ;a dummy byte first.
 136                             ;
 136                             ;  Byte 1 = 00   8 dummy bits
 136                             ;  Byte 2 = 3c   Command nibble (3=write and update) and channel selection
 136                             ;  Byte 3 = dd   Upper 8-bits of the 12-bit voltage value
 136                             ;  Byte 4 = d0   lower 4-bits of the 12-bit voltage value and 4 dummy bits.
 136                             ;
 136                             ;At the end of this communication, the register set [s9,s8,s7,s6] will contain the
 136                             ;data received back from the D/A converter which should be the previous command.
 136                             ;
 136  300FB             set_dac: CALL SPI_init[0FB]                  ;ensure known state of bus and s0 register
 137  0E020                      XOR s0, SPI_dac_cs[20]              ;select low on D/A converter
 138  2C008                      OUTPUT s0, SPI_control_port[08]
 139  00200                      LOAD s2, 00                         ;Write dummy byte to DAC
 13A  3012A                      CALL SPI_dac_tx_rx[12A]
 13B  01920                      LOAD s9, s2                         ;capture response
 13C  012C0                      LOAD s2, sC                         ;Select channel for update
 13D  0A20F                      AND s2, 0F                          ;isolate channel bits to be certain of correct command
 13E  0C230                      OR s2, 30                           ;Use immediate Write and Update command is "0011"
 13F  3012A                      CALL SPI_dac_tx_rx[12A]
 140  01820                      LOAD s8, s2                         ;capture response
 141  20A06                      SL0 sA                              ;data shift bits into correct position
 142  20B00                      SLA sB                              ;with 4 dummy bits ('0') in the least significant bits.
 143  20A06                      SL0 sA
 144  20B00                      SLA sB
 145  20A06                      SL0 sA
 146  20B00                      SLA sB
 147  20A06                      SL0 sA
 148  20B00                      SLA sB
 149  012B0                      LOAD s2, sB                         ;Write 12 bit value followed by 4 dummy bits
 14A  3012A                      CALL SPI_dac_tx_rx[12A]
 14B  01720                      LOAD s7, s2                         ;capture response
 14C  012A0                      LOAD s2, sA
 14D  3012A                      CALL SPI_dac_tx_rx[12A]
 14E  01620                      LOAD s6, s2                         ;capture response
 14F  0E020                      XOR s0, SPI_dac_cs[20]              ;deselect the D/A converter to execute
 150  2C008                      OUTPUT s0, SPI_control_port[08]
 151  2A000                      RETURN
 152                             ;
 152                             ;Perform a hard reset of the D/A converter
 152                             ;
 152  300FB           dac_reset: CALL SPI_init[0FB]                  ;ensure known state of bus and s0 register
 153  0E080                      XOR s0, SPI_dac_clr[80]             ;pulse the clear signal.
 154  2C008                      OUTPUT s0, SPI_control_port[08]
 155  0E080                      XOR s0, SPI_dac_clr[80]
 156  2C008                      OUTPUT s0, SPI_control_port[08]
 157  2A000                      RETURN
 158                             ;
 158                             ;
 158                             ;**************************************************************************************
 158                             ;LCD text messages
 158                             ;**************************************************************************************
 158                             ;
 158                             ;
 158                             ;Display 'PicoBlaze' on LCD at current cursor position
 158                             ;
 158                             ;
 158  00550      disp_PicoBlaze: LOAD s5, character_P[50]
 159  301CA                      CALL LCD_write_data[1CA]
 15A  00569                      LOAD s5, character_i[69]
 15B  301CA                      CALL LCD_write_data[1CA]
 15C  00563                      LOAD s5, character_c[63]
 15D  301CA                      CALL LCD_write_data[1CA]
 15E  0056F                      LOAD s5, character_o[6F]
 15F  301CA                      CALL LCD_write_data[1CA]
 160  00542                      LOAD s5, character_B[42]
 161  301CA                      CALL LCD_write_data[1CA]
 162  0056C                      LOAD s5, character_l[6C]
 163  301CA                      CALL LCD_write_data[1CA]
 164  00561                      LOAD s5, character_a[61]
 165  301CA                      CALL LCD_write_data[1CA]
 166  0057A                      LOAD s5, character_z[7A]
 167  301CA                      CALL LCD_write_data[1CA]
 168  00565                      LOAD s5, character_e[65]
 169  301CA                      CALL LCD_write_data[1CA]
 16A  2A000                      RETURN
 16B                             ;
 16B                             ;
 16B                             ;Display 'ADC Control' on LCD at current cursor position
 16B                             ;
 16B                             ;
 16B  00546         disp_Filter: LOAD s5, character_F[46]
 16C  301CA                      CALL LCD_write_data[1CA]
 16D  00569                      LOAD s5, character_i[69]
 16E  301CA                      CALL LCD_write_data[1CA]
 16F  0056C                      LOAD s5, character_l[6C]
 170  301CA                      CALL LCD_write_data[1CA]
 171  00574                      LOAD s5, character_t[74]
 172  301CA                      CALL LCD_write_data[1CA]
 173  00565                      LOAD s5, character_e[65]
 174  301CA                      CALL LCD_write_data[1CA]
 175  00572                      LOAD s5, character_r[72]
 176  301CA                      CALL LCD_write_data[1CA]
 177  2A000                      RETURN
 178                             ;
 178                             ;
 178                             ;Display 'A/D' on LCD at current cursor position
 178                             ;
 178                             ;
 178  00541             disp_AD: LOAD s5, character_A[41]
 179  301CA                      CALL LCD_write_data[1CA]
 17A  0052F                      LOAD s5, character_divide[2F]
 17B  301CA                      CALL LCD_write_data[1CA]
 17C  00544                      LOAD s5, character_D[44]
 17D  301CA                      CALL LCD_write_data[1CA]
 17E  0053D                      LOAD s5, character_equals[3D]
 17F  301CA                      CALL LCD_write_data[1CA]
 180  2A000                      RETURN
 181                             ;
 181                             ;
 181                             ;
 181                             ;**************************************************************************************
 181                             ;Value to ASCII Conversions and LCD display
 181                             ;**************************************************************************************
 181                             ;
 181                             ;Convert hexadecimal value provided in register s0 into ASCII characters
 181                             ;
 181                             ;The value provided must can be any value in the range 00 to FF and will be converted into
 181                             ;two ASCII characters.
 181                             ;     The upper nibble will be represented by an ASCII character returned in register s2.
 181                             ;     The lower nibble will be represented by an ASCII character returned in register s1.
 181                             ;
 181                             ;The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
 181                             ;added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
 181                             ;hexadecimal requiring a further addition of 07 to the 30 already added.
 181                             ;
 181                             ;Registers used s0, s1 and s2.
 181                             ;
 181  01100   hex_byte_to_ASCII: LOAD s1, s0                         ;remember value supplied
 182  2000E                      SR0 s0                              ;isolate upper nibble
 183  2000E                      SR0 s0
 184  2000E                      SR0 s0
 185  2000E                      SR0 s0
 186  3018D                      CALL hex_to_ASCII[18D]              ;convert
 187  01200                      LOAD s2, s0                         ;upper nibble value in s2
 188  01010                      LOAD s0, s1                         ;restore complete value
 189  0A00F                      AND s0, 0F                          ;isolate lower nibble
 18A  3018D                      CALL hex_to_ASCII[18D]              ;convert
 18B  01100                      LOAD s1, s0                         ;lower nibble value in s1
 18C  2A000                      RETURN
 18D                             ;
 18D                             ;Convert hexadecimal value provided in register s0 into ASCII character
 18D                             ;
 18D                             ;Register used s0
 18D                             ;
 18D  1C00A        hex_to_ASCII: SUB s0, 0A                          ;test if value is in range 0 to 9
 18E  35990                      JUMP C, number_char[190]
 18F  18007                      ADD s0, 07                          ;ASCII char A to F in range 41 to 46
 190  1803A         number_char: ADD s0, 3A                          ;ASCII char 0 to 9 in range 30 to 40
 191  2A000                      RETURN
 192                             ;
 192                             ;
 192                             ;Display the two character HEX value of the register contents 's0' on
 192                             ;the LCD display at the current cursor position.
 192                             ;
 192                             ;Registers used s0, s1, s2, s4, s5, s6
 192                             ;
 192  30181       disp_hex_byte: CALL hex_byte_to_ASCII[181]
 193  01610                      LOAD s6, s1                         ;remember lower hex character
 194  01520                      LOAD s5, s2                         ;display upper hex character
 195  301CA                      CALL LCD_write_data[1CA]
 196  01560                      LOAD s5, s6                         ;display lower hex character
 197  301CA                      CALL LCD_write_data[1CA]
 198  2A000                      RETURN
 199                             ;
 199                             ;
 199                             ;**************************************************************************************
 199                             ;Software delay routines
 199                             ;**************************************************************************************
 199                             ;
 199                             ;
 199                             ;
 199                             ;Delay of 1us.
 199                             ;
 199                             ;Constant value defines reflects the clock applied to KCPSM3. Every instruction
 199                             ;executes in 2 clock cycles making the calculation highly predictable. The '6' in
 199                             ;the following equation even allows for 'CALL delay_1us' instruction in the initiating code.
 199                             ;
 199                             ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
 199                             ;
 199                             ;Registers used s0
 199                             ;
 199  0000B           delay_1us: LOAD s0, delay_1us_constant[0B]
 19A  1C001            wait_1us: SUB s0, 01
 19B  3559A                      JUMP NZ, wait_1us[19A]
 19C  2A000                      RETURN
 19D                             ;
 19D                             ;Delay of 40us.
 19D                             ;
 19D                             ;Registers used s0, s1
 19D                             ;
 19D  00128          delay_40us: LOAD s1, 28                         ;40 x 1us = 40us
 19E  30199           wait_40us: CALL delay_1us[199]
 19F  1C101                      SUB s1, 01
 1A0  3559E                      JUMP NZ, wait_40us[19E]
 1A1  2A000                      RETURN
 1A2                             ;
 1A2                             ;
 1A2                             ;Delay of 1ms.
 1A2                             ;
 1A2                             ;Registers used s0, s1, s2
 1A2                             ;
 1A2  00219           delay_1ms: LOAD s2, 19                         ;25 x 40us = 1ms
 1A3  3019D            wait_1ms: CALL delay_40us[19D]
 1A4  1C201                      SUB s2, 01
 1A5  355A3                      JUMP NZ, wait_1ms[1A3]
 1A6  2A000                      RETURN
 1A7                             ;
 1A7                             ;Delay of 20ms.
 1A7                             ;
 1A7                             ;Delay of 20ms used during initialisation.
 1A7                             ;
 1A7                             ;Registers used s0, s1, s2, s3
 1A7                             ;
 1A7  00314          delay_20ms: LOAD s3, 14                         ;20 x 1ms = 20ms
 1A8  301A2           wait_20ms: CALL delay_1ms[1A2]
 1A9  1C301                      SUB s3, 01
 1AA  355A8                      JUMP NZ, wait_20ms[1A8]
 1AB  2A000                      RETURN
 1AC                             ;
 1AC                             ;Delay of approximately 1 second.
 1AC                             ;
 1AC                             ;Registers used s0, s1, s2, s3, s4
 1AC                             ;
 1AC  00432            delay_1s: LOAD s4, 32                         ;50 x 20ms = 1000ms
 1AD  301A7             wait_1s: CALL delay_20ms[1A7]
 1AE  1C401                      SUB s4, 01
 1AF  355AD                      JUMP NZ, wait_1s[1AD]
 1B0  2A000                      RETURN
 1B1                             ;
 1B1                             ;
 1B1                             ;
 1B1                             ;**************************************************************************************
 1B1                             ;LCD Character Module Routines
 1B1                             ;**************************************************************************************
 1B1                             ;
 1B1                             ;LCD module is a 16 character by 2 line display but all displays are very similar
 1B1                             ;The 4-wire data interface will be used (DB4 to DB7).
 1B1                             ;
 1B1                             ;The LCD modules are relatively slow and software delay loops are used to slow down
 1B1                             ;KCPSM3 adequately for the LCD to communicate. The delay routines are provided in
 1B1                             ;a different section (see above in this case).
 1B1                             ;
 1B1                             ;
 1B1                             ;Pulse LCD enable signal 'E' high for greater than 230ns (1us is used).
 1B1                             ;
 1B1                             ;Register s4 should define the current state of the LCD output port.
 1B1                             ;
 1B1                             ;Registers used s0, s4
 1B1                             ;
 1B1  0E401         LCD_pulse_E: XOR s4, LCD_E[01]                   ;E=1
 1B2  2C440                      OUTPUT s4, LCD_output_port[40]
 1B3  30199                      CALL delay_1us[199]
 1B4  0E401                      XOR s4, LCD_E[01]                   ;E=0
 1B5  2C440                      OUTPUT s4, LCD_output_port[40]
 1B6  2A000                      RETURN
 1B7                             ;
 1B7                             ;Write 4-bit instruction to LCD display.
 1B7                             ;
 1B7                             ;The 4-bit instruction should be provided in the upper 4-bits of register s4.
 1B7                             ;Note that this routine does not release the master enable but as it is only
 1B7                             ;used during initialisation and as part of the 8-bit instruction write it
 1B7                             ;should be acceptable.
 1B7                             ;
 1B7                             ;Registers used s4
 1B7                             ;
 1B7  0A4F8     LCD_write_inst4: AND s4, F8                          ;Enable=1 RS=0 Instruction, RW=0 Write, E=0
 1B8  2C440                      OUTPUT s4, LCD_output_port[40]      ;set up RS and RW >40ns before enable pulse
 1B9  301B1                      CALL LCD_pulse_E[1B1]
 1BA  2A000                      RETURN
 1BB                             ;
 1BB                             ;
 1BB                             ;Write 8-bit instruction to LCD display.
 1BB                             ;
 1BB                             ;The 8-bit instruction should be provided in register s5.
 1BB                             ;Instructions are written using the following sequence
 1BB                             ; Upper nibble
 1BB                             ; wait >1us
 1BB                             ; Lower nibble
 1BB                             ; wait >40us
 1BB                             ;
 1BB                             ;Registers used s0, s1, s4, s5
 1BB                             ;
 1BB  01450     LCD_write_inst8: LOAD s4, s5
 1BC  0A4F0                      AND s4, F0                          ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
 1BD  0C408                      OR s4, LCD_drive[08]                ;Enable=1
 1BE  301B7                      CALL LCD_write_inst4[1B7]           ;write upper nibble
 1BF  30199                      CALL delay_1us[199]                 ;wait >1us
 1C0  01450                      LOAD s4, s5                         ;select lower nibble with
 1C1  20407                      SL1 s4                              ;Enable=1
 1C2  20406                      SL0 s4                              ;RS=0 Instruction
 1C3  20406                      SL0 s4                              ;RW=0 Write
 1C4  20406                      SL0 s4                              ;E=0
 1C5  301B7                      CALL LCD_write_inst4[1B7]           ;write lower nibble
 1C6  3019D                      CALL delay_40us[19D]                ;wait >40us
 1C7  004F0                      LOAD s4, F0                         ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
 1C8  2C440                      OUTPUT s4, LCD_output_port[40]      ;Release master enable
 1C9  2A000                      RETURN
 1CA                             ;
 1CA                             ;
 1CA                             ;
 1CA                             ;Write 8-bit data to LCD display.
 1CA                             ;
 1CA                             ;The 8-bit data should be provided in register s5.
 1CA                             ;Data bytes are written using the following sequence
 1CA                             ; Upper nibble
 1CA                             ; wait >1us
 1CA                             ; Lower nibble
 1CA                             ; wait >40us
 1CA                             ;
 1CA                             ;Registers used s0, s1, s4, s5
 1CA                             ;
 1CA  01450      LCD_write_data: LOAD s4, s5
 1CB  0A4F0                      AND s4, F0                          ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
 1CC  0C40C                      OR s4, 0C                           ;Enable=1 RS=1 Data, RW=0 Write, E=0
 1CD  2C440                      OUTPUT s4, LCD_output_port[40]      ;set up RS and RW >40ns before enable pulse
 1CE  301B1                      CALL LCD_pulse_E[1B1]               ;write upper nibble
 1CF  30199                      CALL delay_1us[199]                 ;wait >1us
 1D0  01450                      LOAD s4, s5                         ;select lower nibble with
 1D1  20407                      SL1 s4                              ;Enable=1
 1D2  20407                      SL1 s4                              ;RS=1 Data
 1D3  20406                      SL0 s4                              ;RW=0 Write
 1D4  20406                      SL0 s4                              ;E=0
 1D5  2C440                      OUTPUT s4, LCD_output_port[40]      ;set up RS and RW >40ns before enable pulse
 1D6  301B1                      CALL LCD_pulse_E[1B1]               ;write lower nibble
 1D7  3019D                      CALL delay_40us[19D]                ;wait >40us
 1D8  004F0                      LOAD s4, F0                         ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
 1D9  2C440                      OUTPUT s4, LCD_output_port[40]      ;Release master enable
 1DA  2A000                      RETURN
 1DB                             ;
 1DB                             ;
 1DB                             ;
 1DB                             ;
 1DB                             ;Read 8-bit data from LCD display.
 1DB                             ;
 1DB                             ;The 8-bit data will be read from the current LCD memory address
 1DB                             ;and will be returned in register s5.
 1DB                             ;It is advisable to set the LCD address (cursor position) before
 1DB                             ;using the data read for the first time otherwise the display may
 1DB                             ;generate invalid data on the first read.
 1DB                             ;
 1DB                             ;Data bytes are read using the following sequence
 1DB                             ; Upper nibble
 1DB                             ; wait >1us
 1DB                             ; Lower nibble
 1DB                             ; wait >40us
 1DB                             ;
 1DB                             ;Registers used s0, s1, s4, s5
 1DB                             ;
 1DB  0040E      LCD_read_data8: LOAD s4, 0E                         ;Enable=1 RS=1 Data, RW=1 Read, E=0
 1DC  2C440                      OUTPUT s4, LCD_output_port[40]      ;set up RS and RW >40ns before enable pulse
 1DD  0E401                      XOR s4, LCD_E[01]                   ;E=1
 1DE  2C440                      OUTPUT s4, LCD_output_port[40]
 1DF  30199                      CALL delay_1us[199]                 ;wait >260ns to access data
 1E0  04502                      INPUT s5, LCD_input_port[02]        ;read upper nibble
 1E1  0E401                      XOR s4, LCD_E[01]                   ;E=0
 1E2  2C440                      OUTPUT s4, LCD_output_port[40]
 1E3  30199                      CALL delay_1us[199]                 ;wait >1us
 1E4  0E401                      XOR s4, LCD_E[01]                   ;E=1
 1E5  2C440                      OUTPUT s4, LCD_output_port[40]
 1E6  30199                      CALL delay_1us[199]                 ;wait >260ns to access data
 1E7  04002                      INPUT s0, LCD_input_port[02]        ;read lower nibble
 1E8  0E401                      XOR s4, LCD_E[01]                   ;E=0
 1E9  2C440                      OUTPUT s4, LCD_output_port[40]
 1EA  0A5F0                      AND s5, F0                          ;merge upper and lower nibbles
 1EB  2000E                      SR0 s0
 1EC  2000E                      SR0 s0
 1ED  2000E                      SR0 s0
 1EE  2000E                      SR0 s0
 1EF  0D500                      OR s5, s0
 1F0  00404                      LOAD s4, 04                         ;Enable=0 RS=1 Data, RW=0 Write, E=0
 1F1  2C440                      OUTPUT s4, LCD_output_port[40]      ;Stop reading 5V device and release master enable
 1F2  3019D                      CALL delay_40us[19D]                ;wait >40us
 1F3  2A000                      RETURN
 1F4                             ;
 1F4                             ;
 1F4                             ;Reset and initialise display to communicate using 4-bit data mode
 1F4                             ;Includes routine to clear the display.
 1F4                             ;
 1F4                             ;Requires the 4-bit instructions 3,3,3,2 to be sent with suitable delays
 1F4                             ;following by the 8-bit instructions to set up the display.
 1F4                             ;
 1F4                             ;  28 = '001' Function set, '0' 4-bit mode, '1' 2-line, '0' 5x7 dot matrix, 'xx'
 1F4                             ;  06 = '000001' Entry mode, '1' increment, '0' no display shift
 1F4                             ;  0C = '00001' Display control, '1' display on, '0' cursor off, '0' cursor blink off
 1F4                             ;  01 = '00000001' Display clear
 1F4                             ;
 1F4                             ;Registers used s0, s1, s2, s3, s4
 1F4                             ;
 1F4  301A7           LCD_reset: CALL delay_20ms[1A7]                ;wait more that 15ms for display to be ready
 1F5  00430                      LOAD s4, 30
 1F6  301B7                      CALL LCD_write_inst4[1B7]           ;send '3'
 1F7  301A7                      CALL delay_20ms[1A7]                ;wait >4.1ms
 1F8  301B7                      CALL LCD_write_inst4[1B7]           ;send '3'
 1F9  301A2                      CALL delay_1ms[1A2]                 ;wait >100us
 1FA  301B7                      CALL LCD_write_inst4[1B7]           ;send '3'
 1FB  3019D                      CALL delay_40us[19D]                ;wait >40us
 1FC  00420                      LOAD s4, 20
 1FD  301B7                      CALL LCD_write_inst4[1B7]           ;send '2'
 1FE  3019D                      CALL delay_40us[19D]                ;wait >40us
 1FF  00528                      LOAD s5, 28                         ;Function set
 200  301BB                      CALL LCD_write_inst8[1BB]
 201  00506                      LOAD s5, 06                         ;Entry mode
 202  301BB                      CALL LCD_write_inst8[1BB]
 203  0050C                      LOAD s5, 0C                         ;Display control
 204  301BB                      CALL LCD_write_inst8[1BB]
 205  00501           LCD_clear: LOAD s5, 01                         ;Display clear
 206  301BB                      CALL LCD_write_inst8[1BB]
 207  301A2                      CALL delay_1ms[1A2]                 ;wait >1.64ms for display to clear
 208  301A2                      CALL delay_1ms[1A2]
 209  2A000                      RETURN
 20A                             ;
 20A                             ;Position the cursor ready for characters to be written.
 20A                             ;The display is formed of 2 lines of 16 characters and each
 20A                             ;position has a corresponding address as indicated below.
 20A                             ;
 20A                             ;                   Character position
 20A                             ;           0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
 20A                             ;
 20A                             ; Line 1 - 80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F
 20A                             ; Line 2 - C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF
 20A                             ;
 20A                             ;This routine will set the cursor position using the value provided
 20A                             ;in register s5. The upper nibble will define the line and the lower
 20A                             ;nibble the character position on the line.
 20A                             ; Example s5 = 2B will position the cursor on line 2 position 11
 20A                             ;
 20A                             ;Registers used s0, s1, s2, s3, s4
 20A                             ;
 20A  12510          LCD_cursor: TEST s5, 10                         ;test for line 1
 20B  35210                      JUMP Z, set_line2[210]
 20C  0A50F                      AND s5, 0F                          ;make address in range 80 to 8F for line 1
 20D  0C580                      OR s5, 80
 20E  301BB                      CALL LCD_write_inst8[1BB]           ;instruction write to set cursor
 20F  2A000                      RETURN
 210  0A50F           set_line2: AND s5, 0F                          ;make address in range C0 to CF for line 2
 211  0C5C0                      OR s5, C0
 212  301BB                      CALL LCD_write_inst8[1BB]           ;instruction write to set cursor
 213  2A000                      RETURN
 214                             ;
 214                             ;
 214                             ;**************************************************************************************
 214                             ;Interrupt Service Routine (ISR)
 214                             ;**************************************************************************************
 214                             ;
 214                             ;Interrupts occur at 1 second intervals.
 214                             ;;;;;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;;;;;;;;;;
 214                             ; HAVE TO CHANGE FROM 1Hz to XYZkHz.
 214                             ;;;;;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;;;;;;;;;;
 214                             ;;;;;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;;;;;;;;;;
 214                             ;;;;;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;;;;;;;;;;
 214                             ;
 214                             ;
 214                             ;Each interrupt is used to take analogue samples and store them in scratch pad memory.
 214                             ;The interrupt clears a 'flag' in register sF so that the main program can advance.
 214                             ;
 214                             ;Each interrupt is the fundamental timing trigger used to set the sample rate and
 214                             ;it is therefore use to set the D/A outputs by copying the values stored in
 214                             ;scratch pad memory and outputting them to the D/A converter using the SPI bus.
 214                             ;
 214                             ;Because the SPI communication is in itself a predictable process, the sample rate
 214                             ;is preserved without sample jitter. All variable activities are left to the main
 214                             ;program.
 214                             ;
 214                             ;Each time PicoBlaze transmits a 32-bit command word to the D/A converter, the
 214                             ;D/A responds with the last command it was sent. So as the end of this service routine
 214                             ;the register set [s9,s8,s7,s6] will contain the command which has just been sent
 214                             ;for the setting of channel C.
 214                             ;
 214  3010F                 ISR: CALL adc_read[10F]                  ;read A/D Converter
 215  2E800                      STORE s8, ADC0_lsb[00]              ;store ADC Channel 0
 216  2E901                      STORE s9, ADC0_msb[01]
 217                             ;
 217  00F00                      LOAD sF, 00                         ;clear flag
 218  38001                      RETURNI ENABLE
 219                             ;
 219                             ;
 219                             ;**************************************************************************************
 219                             ;Interrupt Vector
 219                             ;**************************************************************************************
 219                             ;
 3FF                             ADDRESS 3FF
 3FF  34214                      JUMP ISR[214]
 3FF                             ;
 3FF                             ;
