KCPSM3 Assembler log file for program 'adda_ctr.psm'.
Generated by KCPSM3 version 1.30
Ken Chapman (Xilinx Ltd) 2005.
20Mar2009-21:37:18

 Addr Code

 000                             ;KCPSM3 Program - SPI Control of Amplifier and A/D converter on Spartan-3E Starter Kit.
 000                             ;
 000                             ;
 000                             ;Ken Chapman - Xilinx Ltd
 000                             ;
 000                             ;Version v1.00 - 21th December 2005
 000                             ;
 000                             ;This program uses an 8KHz interrupt to generate test waveforms on the
 000                             ;4 analogue outputs provided by the Linear Technology LTC2624 device.
 000                             ;
 000                             ;As well as the port connections vital to communication with the UART and the SPI
 000                             ;FLASH memory, there are additional port connections used to disable the other
 000                             ;devices sharing the SPI bus on the Starter Kit board. Although these could have been
 000                             ;controlled at the hardware level, they are included in this code to aid
 000                             ;future investigations of communication with the other SPI devices using PicoBlaze.
 000                             ;
 000                             ;Connections to the LEDs, switches and press buttons are provided to aid
 000                             ;development and enable further experiments. Otherwise know as having fun!
 000                             ;
 000                             ;Port definitions
 000                             ;
 000                             ;
 000                             CONSTANT SPI_control_port, 08       ;SPI clock and chip selects
 000                             CONSTANT SPI_sck, 01                ;                  SCK - bit0
 000                             CONSTANT SPI_rom_cs, 02             ;    serial rom select - bit1
 000                             CONSTANT SPI_spare_control, 04      ;                spare - bit2
 000                             CONSTANT SPI_amp_cs, 08             ;     amplifier select - bit3
 000                             CONSTANT SPI_adc_conv, 10           ;          A/D convert - bit4
 000                             CONSTANT SPI_dac_cs, 20             ;           D/A select - bit5
 000                             CONSTANT SPI_amp_shdn, 40           ;       amplifier SHDN - bit6
 000                             CONSTANT SPI_dac_clr, 80            ;            D/A clear - bit7
 000                             ;
 000                             CONSTANT SPI_output_port, 04        ;SPI data output
 000                             CONSTANT SPI_sdo, 80                ;   SDO - bit7
 000                             ;
 000                             CONSTANT SPI_input_port, 01         ;SPI data input
 000                             CONSTANT SPI_sdi, 80                ;             SDI - bit7
 000                             CONSTANT SPI_amp_sdi, 40            ;   amplifier SDI - bit6
 000                             ;
 000                             ;
 000                             CONSTANT LED_port, 80               ;8 simple LEDs
 000                             CONSTANT LED0, 01                   ;     LED 0 - bit0
 000                             CONSTANT LED1, 02                   ;         1 - bit1
 000                             CONSTANT LED2, 04                   ;         2 - bit2
 000                             CONSTANT LED3, 08                   ;         3 - bit3
 000                             CONSTANT LED4, 10                   ;         4 - bit4
 000                             CONSTANT LED5, 20                   ;         5 - bit5
 000                             CONSTANT LED6, 40                   ;         6 - bit6
 000                             CONSTANT LED7, 80                   ;         7 - bit7
 000                             ;
 000                             ;
 000                             CONSTANT switch_port, 00            ;Read switches and press buttons
 000                             CONSTANT BTN_north, 01              ;  Buttons     North - bit0
 000                             CONSTANT BTN_east, 02               ;               East - bit1
 000                             CONSTANT BTN_south, 04              ;              South - bit2
 000                             CONSTANT BTN_west, 08               ;               West - bit3
 000                             CONSTANT switch0, 10                ;  Switches        0 - bit4
 000                             CONSTANT switch1, 20                ;                  1 - bit5
 000                             CONSTANT switch2, 40                ;                  2 - bit6
 000                             CONSTANT switch3, 80                ;                  3 - bit7
 000                             ;
 000                             ;LCD interface ports
 000                             ;
 000                             ;The master enable signal is not used by the LCD display itself
 000                             ;but may be required to confirm that LCD communication is active.
 000                             ;This is required on the Spartan-3E Starter Kit if the StrataFLASH
 000                             ;is used because it shares the same data pins and conflicts must be avoided.
 000                             ;
 000                             CONSTANT LCD_output_port, 40        ;LCD character module output data and control
 000                             CONSTANT LCD_E, 01                  ;   active High Enable        E - bit0
 000                             CONSTANT LCD_RW, 02                 ;   Read=1 Write=0           RW - bit1
 000                             CONSTANT LCD_RS, 04                 ;   Instruction=0 Data=1     RS - bit2
 000                             CONSTANT LCD_drive, 08              ;   Master enable (active High) - bit3
 000                             CONSTANT LCD_DB4, 10                ;   4-bit              Data DB4 - bit4
 000                             CONSTANT LCD_DB5, 20                ;   interface          Data DB5 - bit5
 000                             CONSTANT LCD_DB6, 40                ;                      Data DB6 - bit6
 000                             CONSTANT LCD_DB7, 80                ;                      Data DB7 - bit7
 000                             ;
 000                             ;
 000                             CONSTANT LCD_input_port, 02         ;LCD character module input data
 000                             CONSTANT LCD_read_spare0, 01        ;    Spare bits               - bit0
 000                             CONSTANT LCD_read_spare1, 02        ;    are zero                 - bit1
 000                             CONSTANT LCD_read_spare2, 04        ;                             - bit2
 000                             CONSTANT LCD_read_spare3, 08        ;                             - bit3
 000                             CONSTANT LCD_read_DB4, 10           ;    4-bit           Data DB4 - bit4
 000                             CONSTANT LCD_read_DB5, 20           ;    interface       Data DB5 - bit5
 000                             CONSTANT LCD_read_DB6, 40           ;                    Data DB6 - bit6
 000                             CONSTANT LCD_read_DB7, 80           ;                    Data DB7 - bit7
 000                             ;
 000                             ;
 000                             ;
 000                             ;
 000                             ;Special Register usage
 000                             ;
 000                             ;
 000                             ;
 000                             ;Scratch Pad Memory Locations
 000                             ;
 000                             ;Values read from the A/D converter
 000                             ;
 000                             CONSTANT ADC0_lsb, 00               ;ADC Channel 0 value LS-Byte
 000                             CONSTANT ADC0_msb, 01               ;                    MS-Byte
 000                             ;
 000                             CONSTANT ADC1_lsb, 02               ;ADC Channel 1 value LS-Byte
 000                             CONSTANT ADC1_msb, 03               ;                    MS-Byte
 000                             ;
 000                             ;Amplifier gain settings.
 000                             ;
 000                             ;Stored value is the 4-bit code for gain setting
 000                             ;  Code  1   2   3    4     5    6     7
 000                             ;  Gain -1  -2  -5  -10   -20  -50  -100
 000                             CONSTANT amp_A_gain, 04             ;Amplifier A gain value
 000                             CONSTANT amp_B_gain, 05             ;Amplifier B gain value
 000                             ;
 000                             ;Sample counter used to give activity indication on LEDs
 000                             ;
 000                             CONSTANT sample_count, 06           ;8-bit counter LS-Byte
 000                             ;
 000                             CONSTANT decimal0, 07               ;5 digit decimal value
 000                             CONSTANT decimal1, 08
 000                             CONSTANT decimal2, 09
 000                             CONSTANT decimal3, 0A
 000                             CONSTANT decimal4, 0B
 000                             ;
 000                             ;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;
 000                             ;Values to be written to the D/A converter
 000                             CONSTANT chan_A_lsb, 0C             ;Channel C value LS-Byte
 000                             CONSTANT chan_A_msb, 0E             ;                MS-Byte
 000                             ;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;
 000                             ;
 000                             ;
 000                             ;Useful data constants
 000                             ;
 000                             CONSTANT VREF_lsb, 72               ;Reference voltage in milli-volts
 000                             CONSTANT VREF_msb, 06               ;Nominal value 1.65v so value is 1650 (0672 hex)
 000                             ;
 000                             ;Constant to define a software delay of 1us. This must be adjusted to reflect the
 000                             ;clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
 000                             ;calculation highly predictable. The '6' in the following equation even allows for
 000                             ;'CALL delay_1us' instruction in the initiating code.
 000                             ;
 000                             ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
 000                             ;
 000                             ;Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
 000                             ;For clock rates below 10MHz the value of 1 must be used and the operation will
 000                             ;become lower than intended.
 000                             ;
 000                             CONSTANT delay_1us_constant, 0B
 000                             ;
 000                             ;
 000                             ;
 000                             ;ASCII table
 000                             ;
 000                             CONSTANT character_a, 61
 000                             CONSTANT character_b, 62
 000                             CONSTANT character_c, 63
 000                             CONSTANT character_d, 64
 000                             CONSTANT character_e, 65
 000                             CONSTANT character_f, 66
 000                             CONSTANT character_g, 67
 000                             CONSTANT character_h, 68
 000                             CONSTANT character_i, 69
 000                             CONSTANT character_j, 6A
 000                             CONSTANT character_k, 6B
 000                             CONSTANT character_l, 6C
 000                             CONSTANT character_m, 6D
 000                             CONSTANT character_n, 6E
 000                             CONSTANT character_o, 6F
 000                             CONSTANT character_p, 70
 000                             CONSTANT character_q, 71
 000                             CONSTANT character_r, 72
 000                             CONSTANT character_s, 73
 000                             CONSTANT character_t, 74
 000                             CONSTANT character_u, 75
 000                             CONSTANT character_v, 76
 000                             CONSTANT character_w, 77
 000                             CONSTANT character_x, 78
 000                             CONSTANT character_y, 79
 000                             CONSTANT character_z, 7A
 000                             CONSTANT character_A, 41
 000                             CONSTANT character_B, 42
 000                             CONSTANT character_C, 43
 000                             CONSTANT character_D, 44
 000                             CONSTANT character_E, 45
 000                             CONSTANT character_F, 46
 000                             CONSTANT character_G, 47
 000                             CONSTANT character_H, 48
 000                             CONSTANT character_I, 49
 000                             CONSTANT character_J, 4A
 000                             CONSTANT character_K, 4B
 000                             CONSTANT character_L, 4C
 000                             CONSTANT character_M, 4D
 000                             CONSTANT character_N, 4E
 000                             CONSTANT character_O, 4F
 000                             CONSTANT character_P, 50
 000                             CONSTANT character_Q, 51
 000                             CONSTANT character_R, 52
 000                             CONSTANT character_S, 53
 000                             CONSTANT character_T, 54
 000                             CONSTANT character_U, 55
 000                             CONSTANT character_V, 56
 000                             CONSTANT character_W, 57
 000                             CONSTANT character_X, 58
 000                             CONSTANT character_Y, 59
 000                             CONSTANT character_Z, 5A
 000                             CONSTANT character_0, 30
 000                             CONSTANT character_1, 31
 000                             CONSTANT character_2, 32
 000                             CONSTANT character_3, 33
 000                             CONSTANT character_4, 34
 000                             CONSTANT character_5, 35
 000                             CONSTANT character_6, 36
 000                             CONSTANT character_7, 37
 000                             CONSTANT character_8, 38
 000                             CONSTANT character_9, 39
 000                             CONSTANT character_colon, 3A
 000                             CONSTANT character_stop, 2E
 000                             CONSTANT character_semi_colon, 3B
 000                             CONSTANT character_minus, 2D
 000                             CONSTANT character_divide, 2F       ;'/'
 000                             CONSTANT character_plus, 2B
 000                             CONSTANT character_comma, 2C
 000                             CONSTANT character_less_than, 3C
 000                             CONSTANT character_greater_than, 3E
 000                             CONSTANT character_equals, 3D
 000                             CONSTANT character_space, 20
 000                             CONSTANT character_CR, 0D           ;carriage return
 000                             CONSTANT character_question, 3F     ;'?'
 000                             CONSTANT character_dollar, 24
 000                             CONSTANT character_exclaim, 21      ;'!'
 000                             CONSTANT character_BS, 08           ;Back Space command character
 000                             ;
 000                             ;
 000                             ;
 000                             ;
 000                             ;
 000                             ;
 000                             ;Initialise the system
 000                             ;
 000                             ;
 000  3010E          cold_start: CALL SPI_init[10E]                  ;initialise SPI bus ports
 001  30218                      CALL LCD_reset[218]                 ;initialise LCD display
 002                             ;
 002                             ;Write welcome message to LCD display
 002                             ;
 002  00523                      LOAD s5, 23                         ;Line 2 position 3
 003  3022E                      CALL LCD_cursor[22E]
 004  3017E                      CALL disp_ADC_Control[17E]
 005  301D0                      CALL delay_1s[1D0]                  ;wait 5 seconds
 006  301D0                      CALL delay_1s[1D0]
 007  30229                      CALL LCD_clear[229]                 ;Clear display
 008                             ;
 008  00000                      LOAD s0, 00                         ;clear event counter
 009  2E006                      STORE s0, sample_count[06]
 00A                             ;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;
 00A  2E00C                      STORE s0, chan_A_lsb[0C]            ;clear all internal D/A values
 00B  2E00E                      STORE s0, chan_A_msb[0E]            ;clear all internal D/A values
 00C  30165                      CALL dac_reset[165]                 ;reset D/A converter on all channels
 00D                             ;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;
 00D                             ;
 00D                             ;
 00D                             ;
 00D                             ;
 00D  00001                      LOAD s0, 01                         ;set initial amplifier gain to 1 on both channels
 00E  2E004                      STORE s0, amp_A_gain[04]
 00F  2E005                      STORE s0, amp_B_gain[05]
 010  34085                      JUMP new_gain_set[085]              ;set, display the initial gain and enable interrupts
 011                             ;
 011                             ;
 011                             ;The program is interrupt driven to maintain an 8KHz sample rate. The main body
 011                             ;of the program waits for an interrupt to occur. The interrupt updates all four
 011                             ;analogue outputs with values stored in scratch pad memory. This takes approximately
 011                             ;58us of the 125us available between interrupts. The main program then prepares
 011                             ;new values for the analogue outputs (in less than 67us) before waiting for the
 011                             ;next interrupt.
 011                             ;
 011                             ;
 011  00FFF          warm_start: LOAD sF, FF                         ;flag set and wait for interrupt to be serviced
 012  3C001                      ENABLE INTERRUPT                    ;normal operation
 013                             ;wait_int: INPUT sE, switch_port               ;test for button press changes to amplifier gain
 013                             ;TEST sE, BTN_north                  ;sE used as this in not effected by ISR
 013                             ;JUMP NZ, gain_increase
 013                             ;TEST sE, BTN_south
 013                             ;JUMP NZ, gain_decrease
 013  14FFF            wait_int: COMPARE sF, FF                      ;wait for interrupt
 014  35013                      JUMP Z, wait_int[013]               ;interrupt clears the flag
 015                             ;
 015                             ;
 015                             ;
 015                             ;Drive LEDs with simple binary count of the samples to indicate
 015                             ;that the design is active.
 015                             ;
 015                             ;FETCH s0, sample_count              ;increment counter
 015                             ;ADD s0, 01
 015                             ;STORE s0, sample_count
 015                             ;OUTPUT s0, LED_port                 ;count increments at 1Hz
 015                             ;OUTPUT s0, LED_port                 ;count increments at 1Hz
 015                             ;
 015                             ;
 015                             ;Display the A/D Channel 0 value as hex on LCD
 015                             ;
 015                             ;LOAD s5, 2C                         ;Line 2 position 12
 015                             ;CALL LCD_cursor
 015                             ;FETCH s0, ADC0_msb
 015                             ;CALL disp_hex_byte
 015                             ;FETCH s0, ADC0_lsb
 015                             ;CALL disp_hex_byte
 015                             ;
 015                             ;
 015                             ;
 015                             ;Convert A/D channel 0 value to decimal voltage
 015                             ;
 015                             ;The 14-bit signed value from the A/D (sign extended to 16-bits)
 015                             ;relates to a voltage in the range -1.25v to +1.25v at the input
 015                             ;to the A/D converter relative to the 1.65v mid-rail reference point.
 015                             ;
 015                             ;The 14-bit value can be translated into the -1.25v to +1.25v using the
 015                             ;simple equation...
 015                             ;
 015                             ;   ADin = AD_value x 1.25/8192
 015                             ;
 015                             ;It is possible to scale the AD_value by 1.25/8192 using a fixed point
 015                             ;representation.
 015                             ;
 015                             ;However, it is also possible to scale it by another factor at the
 015                             ;same time which nicely converts to a binary value which is readily
 015                             ;converted to decimal. This can be achieved by example...
 015                             ;
 015                             ;For an input to the A/D converter of +1.25v relative to the reference,
 015                             ;the A/D will output the maximum conversion of 1FFF (+8191).
 015                             ;
 015                             ;In this case we would like to have the result value +1.250v which can be represented
 015                             ;by the integer value +1250 with appropiate positioning of the decimal point.
 015                             ;The constant to achieve this conversion is +1250/8191=+0.152606...
 015                             ;Also a number requiring fixed point representation but how many bits to use?
 015                             ;
 015                             ;The way to resolve this is to realise that a multiplication will be
 015                             ;performed and it would be nice if the +1250 result ended up in a register pair.
 015                             ;So if we perform a 16x16-bit multiplication such that the upper 16-bits of
 015                             ;the 32-bit result is the required value, then everything will resolve itself.
 015                             ;
 015                             ;Hence the constant required is actually (1250x(2^16))/8191=+10001 (2711 hex).
 015                             ;
 015                             ;Using the example 1FFF x 2711 = 04E1F8EF
 015                             ;   of which the upper 16-bits = 04E1 (+1249 decimal)
 015                             ;
 015                             ;Likewise the other limit case is E000 x 2711 = FB1DE000
 015                             ;   of which the upper 16-bits = FB1D (-1251 decimal)
 015                             ;
 015                             ;The values can be made perfect by rounding before truncation
 015                             ;
 015  06200                      FETCH s2, ADC0_lsb[00]              ;Read A/D channel 0 value
 016  06301                      FETCH s3, ADC0_msb[01]
 017  00011                      LOAD s0, 11                         ;scaling value for input to A/D converter
 018  00127                      LOAD s1, 27
 019  300D3                      CALL mult_16x16s[0D3]               ;[s7,s6,s5,s4]=[s3,s2]x[s1,s0]
 01A  20506                      SL0 s5                              ;round value before truncation
 01B  1A600                      ADDCY s6, 00
 01C  1A700                      ADDCY s7, 00
 01D                             ;
 01D                             ;The register pair [s7,s6] now holds the binary value
 01D                             ;representing the input level to the A/D converter in milli-volts.
 01D                             ;This is now displayed on the LCD. Negative values need to be converted to
 01D                             ;signed magnitude for display.
 01D                             ;
 01D                             ;LOAD s5, 20                         ;Line 2 position 0
 01D                             ;CALL LCD_cursor
 01D                             ;CALL disp_AD                        ;display A/D=
 01D  12780                      TEST s7, 80                         ;test sign bit of value
 01E  3541F                      JUMP NZ, neg_AD[01F]
 01F                             ;LOAD s5, character_plus
 01F                             ;JUMP AD_sign
 01F  0E6FF              neg_AD: XOR s6, FF                          ;complement [s7,s6] to make positive
 020  0E7FF                      XOR s7, FF
 021  18601                      ADD s6, 01
 022  1A700                      ADDCY s7, 00
 023                             ;LOAD s5, character_minus
 023                             ;;AD_sign: CALL LCD_write_data                 ;display sign of value
 023                             ;CALL disp_volts                     ;display 4 digit value as X.XXXv
 023                             ;
 023                             ;Convert A/D channel 0 value to display the VINA decimal voltage
 023                             ;
 023                             ;The same fundamental technique can be used to convert the 14-bit
 023                             ;A/D value into the level at the VINA input except that two more factors
 023                             ;must be considered.
 023                             ;
 023                             ;The first is that the amplifier inverts and has gain. Therefore the
 023                             ;VINA input level is opposite polarity and could be a smaller deviation
 023                             ;from the mid rail 1.65v reference.
 023                             ;
 023                             ;Secondly, to display the actual voltage level at the VINA terminal
 023                             ;the 1.65v offset must be added.
 023                             ;
 023                             ;The voltage at the VINA input is therefore...
 023                             ;
 023                             ;   VINA = [AD_value x (1.25/(8192 x G))]+1.65
 023                             ;
 023                             ;Following the same methodology as for the A/D value, it means that there
 023                             ;is a set of scaling factors to deal with the negative gain values.
 023                             ;
 023                             ; K = (+1250 x (2^16)) / (8191 x G)
 023                             ;
 023                             ;        G             K     (K Hex)
 023                             ;       -1          -10001   (D8EF)
 023                             ;       -2           -5001   (EC77)
 023                             ;       -5           -2000   (F830)
 023                             ;      -10           -1000   (FC18)
 023                             ;      -20            -500   (FE0C)
 023                             ;      -50            -200   (FF38)
 023                             ;     -100            -100   (FF9C)
 023                             ;
 023  06200                      FETCH s2, ADC0_lsb[00]              ;Read A/D channel 0 value
 024  06301                      FETCH s3, ADC0_msb[01]
 025  06404                      FETCH s4, amp_A_gain[04]            ;read A gain and select appropiate gain setting
 026  000EF                      LOAD s0, EF                         ;scaling value for amplifier gain of -1
 027  001D8                      LOAD s1, D8
 028  14401                      COMPARE s4, 01
 029  35040                      JUMP Z, mult_VINA[040]
 02A  00077                      LOAD s0, 77                         ;scaling value for amplifier gain of -2
 02B  001EC                      LOAD s1, EC
 02C  14402                      COMPARE s4, 02
 02D  35040                      JUMP Z, mult_VINA[040]
 02E  00030                      LOAD s0, 30                         ;scaling value for amplifier gain of -5
 02F  001F8                      LOAD s1, F8
 030  14403                      COMPARE s4, 03
 031  35040                      JUMP Z, mult_VINA[040]
 032  00018                      LOAD s0, 18                         ;scaling value for amplifier gain of -10
 033  001FC                      LOAD s1, FC
 034  14405                      COMPARE s4, 05
 035  35040                      JUMP Z, mult_VINA[040]
 036  0000C                      LOAD s0, 0C                         ;scaling value for amplifier gain of -20
 037  001FE                      LOAD s1, FE
 038  14406                      COMPARE s4, 06
 039  35040                      JUMP Z, mult_VINA[040]
 03A  00038                      LOAD s0, 38                         ;scaling value for amplifier gain of -50
 03B  001FF                      LOAD s1, FF
 03C  14401                      COMPARE s4, 01
 03D  35040                      JUMP Z, mult_VINA[040]
 03E  0009C                      LOAD s0, 9C                         ;scaling value for amplifier gain of -100
 03F  001FF                      LOAD s1, FF
 040  300D3           mult_VINA: CALL mult_16x16s[0D3]               ;[s7,s6,s5,s4]=[s3,s2]x[s1,s0]
 041  20506                      SL0 s5                              ;round value before truncation
 042  1A600                      ADDCY s6, 00
 043  1A700                      ADDCY s7, 00
 044  18672                      ADD s6, VREF_lsb[72]                ;add 1.65v offset represented at 1650 (0672 hex)
 045  1A706                      ADDCY s7, VREF_msb[06]
 046                             ;
 046                             ;The register pair [s7,s6] now holds the binary value
 046                             ;representing the VINA input level in milli-volts.
 046                             ;This must be a positive value due to the offset of 1.65v
 046                             ;being greater than the maximum relative range of -1.25v to +1.25v.
 046                             ;This binary value can now be converted to a decimal digits
 046                             ;and displayed on the LCD.
 046                             ;
 046                             ;If the A/D value is maximum negative (E000) or maximum positive (1FFF)
 046                             ;then an indication of the actual value being applied being greater or
 046                             ;less than that computed will be made.
 046                             ;
 046                             ;LOAD s5, 17                         ;Line 1 position 7
 046                             ;CALL LCD_cursor
 046                             ;CALL disp_VA                        ;display VA=
 046  06200                      FETCH s2, ADC0_lsb[00]              ;Read A/D channel 0 value
 047  06301                      FETCH s3, ADC0_msb[01]
 048                             ;COMPARE s3, E0                      ;test for maximum negative
 048                             ;JUMP NZ, test_max_pos
 048                             ;COMPARE s2, 00
 048                             ;JUMP NZ, test_max_pos
 048                             ;LOAD s5, character_greater_than     ;display >
 048                             ;CALL LCD_write_data
 048                             ;JUMP disp_VINA_volts
 048                             ;;test_max_pos: COMPARE s3, 1F                      ;test for maximum positive
 048                             ;JUMP NZ, disp_VINA_volts
 048                             ;COMPARE s2, FF
 048                             ;JUMP NZ, disp_VINA_volts
 048                             ;LOAD s5, character_less_than        ;display <
 048                             ;CALL LCD_write_data
 048                             ;;disp_VINA_volts: CALL disp_volts                     ;display 4 digit value as X.XXXv
 048                             ;;;;;;;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;;;;
 048                             ;
 048                             ;
 048                             ;Storing the ADC value in the DAC registers after conditioning:
 048                             ;
 048                             ;FETCH s2, ADC0_msb
 048                             ;FETCH s3, ADC0_lsb
 048  04300                      INPUT s3, switch_port[00]
 049  04200                      INPUT s2, switch_port[00]
 04A  2020A                      SRX s2                              ; shift 12-bit value right 4 places
 04B  20308                      SRA s3
 04C  2020A                      SRX s2
 04D  20308                      SRA s3
 04E  12280                      TEST s2, 80                         ;test sign bit of value
 04F  35457                      JUMP NZ, neg_value_DAC[057]         ;if negative, then actually positive, so add ref.
 050  0000A                      LOAD s0, 0A
 051  0018F                      LOAD s1, 8F
 052  1D130                      SUB s1, s3
 053  1F020                      SUBCY s0, s2
 054  2E00E                      STORE s0, chan_A_msb[0E]            ;store value for D/A output
 055  2E10C                      STORE s1, chan_A_lsb[0C]
 056  34062                      JUMP dac_re_adc_value[062]
 057  0E3FF       neg_value_DAC: XOR s3, FF                          ;complement [s7,s6] to make positive
 058  0E2FF                      XOR s2, FF
 059  18301                      ADD s3, 01
 05A  1A200                      ADDCY s2, 00
 05B  0A203                      AND s2, 03                          ; the first 6 bits should be zero??
 05C  0000A                      LOAD s0, 0A
 05D  0018F                      LOAD s1, 8F
 05E  19130                      ADD s1, s3
 05F  1B020                      ADDCY s0, s2
 060  2E00E                      STORE s0, chan_A_msb[0E]            ;store value for D/A output
 061  2E10C                      STORE s1, chan_A_lsb[0C]
 062  00C00    dac_re_adc_value: LOAD sC, 00                         ;channel A
 063  06B0E                      FETCH sB, chan_A_msb[0E]            ;12-bit value, ;from some reg where adc val is stored
 064  06A0C                      FETCH sA, chan_A_lsb[0C]            ;2 bytes
 065  30149                      CALL set_dac[149]                   ;writing to the channel part
 066                             ;;;;;;;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;;;;
 066  34011                      JUMP warm_start[011]
 067                             ;
 067                             ;
 067                             ;**************************************************************************************
 067                             ;Display voltage level at in the form X.XXX on the LCD at current cursor position
 067                             ;**************************************************************************************
 067                             ;
 067                             ;Value to be displayed must be unsigned (positive) in the
 067                             ;[s7,s6] register pair. Only the lower 4 digits are displayed.
 067                             ;
 067  300F1          disp_volts: CALL integer16_to_BCD[0F1]          ;convert [s7,s6] to BCD in scratch pad memory
 068  0650A                      FETCH s5, decimal3[0A]
 069  18530                      ADD s5, 30                          ;convert to ASCII
 06A  301EE                      CALL LCD_write_data[1EE]
 06B  0052E                      LOAD s5, character_stop[2E]
 06C  301EE                      CALL LCD_write_data[1EE]
 06D  06509                      FETCH s5, decimal2[09]
 06E  18530                      ADD s5, 30                          ;convert to ASCII
 06F  301EE                      CALL LCD_write_data[1EE]
 070  06508                      FETCH s5, decimal1[08]
 071  18530                      ADD s5, 30                          ;convert to ASCII
 072  301EE                      CALL LCD_write_data[1EE]
 073  06507                      FETCH s5, decimal0[07]
 074  18530                      ADD s5, 30                          ;convert to ASCII
 075  301EE                      CALL LCD_write_data[1EE]
 076  00520                      LOAD s5, character_space[20]        ;ensure next position is cleared
 077  301EE                      CALL LCD_write_data[1EE]
 078  2A000                      RETURN
 079                             ;
 079                             ;**************************************************************************************
 079                             ;Changing amplifier gain using press buttons
 079                             ;**************************************************************************************
 079                             ;
 079                             ;Possible gain values are
 079                             ;   Gain   Amplifier
 079                             ;            code
 079                             ;    -1        1
 079                             ;    -2        2
 079                             ;    -5        3
 079                             ;   -10        4
 079                             ;   -20        5
 079                             ;   -50        6
 079                             ;  -100        7
 079                             ;
 079  3C000       gain_increase: DISABLE INTERRUPT                   ;stop normal operation
 07A  06004                      FETCH s0, amp_A_gain[04]            ;read current gain
 07B  18001                      ADD s0, 01
 07C  14008                      COMPARE s0, 08                      ;test for too big
 07D  35485                      JUMP NZ, new_gain_set[085]
 07E  00007                      LOAD s0, 07                         ;maximum gain
 07F  34085                      JUMP new_gain_set[085]
 080  3C000       gain_decrease: DISABLE INTERRUPT                   ;stop normal operation
 081  06004                      FETCH s0, amp_A_gain[04]            ;read current gain
 082  1C001                      SUB s0, 01
 083  35485                      JUMP NZ, new_gain_set[085]
 084  00001                      LOAD s0, 01                         ;minimum gain
 085  2E004        new_gain_set: STORE s0, amp_A_gain[04]            ;store new value
 086  06205                      FETCH s2, amp_B_gain[05]            ;form the amplifier control byte
 087  20206                      SL0 s2                              ;B amplifier set by upper 4 bits
 088  20206                      SL0 s2
 089  20206                      SL0 s2
 08A  20206                      SL0 s2
 08B  0D200                      OR s2, s0                           ;A amplifier set by lower
 08C  30111                      CALL set_amp[111]                   ;set SPI amplifier
 08D                             ;display gain setting on LCD
 08D  00510                      LOAD s5, 10                         ;Line 1 position 0
 08E  3022E                      CALL LCD_cursor[22E]
 08F  00547                      LOAD s5, character_G[47]
 090  301EE                      CALL LCD_write_data[1EE]
 091  0053D                      LOAD s5, character_equals[3D]
 092  301EE                      CALL LCD_write_data[1EE]
 093  0052D                      LOAD s5, character_minus[2D]
 094  301EE                      CALL LCD_write_data[1EE]
 095  06004                      FETCH s0, amp_A_gain[04]            ;read A gain setting
 096  14001                      COMPARE s0, 01                      ;determine actual gain value
 097  3549F                      JUMP NZ, test_A2[09F]
 098  00531                      LOAD s5, character_1[31]            ;gain is -1
 099  301EE                      CALL LCD_write_data[1EE]
 09A  00520                      LOAD s5, character_space[20]
 09B  301EE                      CALL LCD_write_data[1EE]
 09C  00520                      LOAD s5, character_space[20]
 09D  301EE                      CALL LCD_write_data[1EE]
 09E  340D2                      JUMP wait_no_press[0D2]
 09F  14002             test_A2: COMPARE s0, 02
 0A0  354A8                      JUMP NZ, test_A3[0A8]
 0A1  00532                      LOAD s5, character_2[32]            ;gain is -2
 0A2  301EE                      CALL LCD_write_data[1EE]
 0A3  00520                      LOAD s5, character_space[20]
 0A4  301EE                      CALL LCD_write_data[1EE]
 0A5  00520                      LOAD s5, character_space[20]
 0A6  301EE                      CALL LCD_write_data[1EE]
 0A7  340D2                      JUMP wait_no_press[0D2]
 0A8  14003             test_A3: COMPARE s0, 03
 0A9  354B1                      JUMP NZ, test_A4[0B1]
 0AA  00535                      LOAD s5, character_5[35]            ;gain is -5
 0AB  301EE                      CALL LCD_write_data[1EE]
 0AC  00520                      LOAD s5, character_space[20]
 0AD  301EE                      CALL LCD_write_data[1EE]
 0AE  00520                      LOAD s5, character_space[20]
 0AF  301EE                      CALL LCD_write_data[1EE]
 0B0  340D2                      JUMP wait_no_press[0D2]
 0B1  14004             test_A4: COMPARE s0, 04
 0B2  354BA                      JUMP NZ, test_A5[0BA]
 0B3  00531                      LOAD s5, character_1[31]            ;gain is -10
 0B4  301EE                      CALL LCD_write_data[1EE]
 0B5  00530                      LOAD s5, character_0[30]
 0B6  301EE                      CALL LCD_write_data[1EE]
 0B7  00520                      LOAD s5, character_space[20]
 0B8  301EE                      CALL LCD_write_data[1EE]
 0B9  340D2                      JUMP wait_no_press[0D2]
 0BA  14005             test_A5: COMPARE s0, 05
 0BB  354C3                      JUMP NZ, test_A6[0C3]
 0BC  00532                      LOAD s5, character_2[32]            ;gain is -20
 0BD  301EE                      CALL LCD_write_data[1EE]
 0BE  00530                      LOAD s5, character_0[30]
 0BF  301EE                      CALL LCD_write_data[1EE]
 0C0  00520                      LOAD s5, character_space[20]
 0C1  301EE                      CALL LCD_write_data[1EE]
 0C2  340D2                      JUMP wait_no_press[0D2]
 0C3  14006             test_A6: COMPARE s0, 06
 0C4  354CC                      JUMP NZ, gain_A7[0CC]
 0C5  00535                      LOAD s5, character_5[35]            ;gain is -50
 0C6  301EE                      CALL LCD_write_data[1EE]
 0C7  00530                      LOAD s5, character_0[30]
 0C8  301EE                      CALL LCD_write_data[1EE]
 0C9  00520                      LOAD s5, character_space[20]
 0CA  301EE                      CALL LCD_write_data[1EE]
 0CB  340D2                      JUMP wait_no_press[0D2]
 0CC  00531             gain_A7: LOAD s5, character_1[31]            ;gain is -100
 0CD  301EE                      CALL LCD_write_data[1EE]
 0CE  00530                      LOAD s5, character_0[30]
 0CF  301EE                      CALL LCD_write_data[1EE]
 0D0  00530                      LOAD s5, character_0[30]
 0D1  301EE                      CALL LCD_write_data[1EE]
 0D2                             ;;wait_no_press: CALL delay_20ms                     ;delay to help avoid switch bounce
 0D2                             ;INPUT s0, switch_port               ;check for release of press buttons
 0D2                             ;TEST s0, 05                         ;north and south buttons
 0D2                             ;JUMP NZ, wait_no_press
 0D2  34011       wait_no_press: JUMP warm_start[011]
 0D3                             ;
 0D3                             ;**************************************************************************************
 0D3                             ;16-bit by 16-bit Signed multiplier
 0D3                             ;**************************************************************************************
 0D3                             ;
 0D3                             ;16 bit signed multiplication using shift and add technique.
 0D3                             ;The full precision 32-bit product is returned.
 0D3                             ;
 0D3                             ;The key to signed multiplication is to think of all bits of the second operand
 0D3                             ;[s1,s0] as being positive except for the most significant bit. This means that
 0D3                             ;the first operand is added to the result in all cases when there is a '1' in the
 0D3                             ;second operand except for the MSB case when the first operand is subtracted if there
 0D3                             ;is a '1'.
 0D3                             ;
 0D3                             ;[s7,s6,s5,s4]=[s3,s2]x[s1,s0]
 0D3                             ;
 0D3                             ;Registers used s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,sA
 0D3                             ;
 0D3  00700         mult_16x16s: LOAD s7, 00                         ;clear accumulator
 0D4  00600                      LOAD s6, 00
 0D5  00500                      LOAD s5, 00                         ;Set bit 14 to act as a bit shift counter
 0D6  00400                      LOAD s4, 00
 0D7  00800                      LOAD s8, 00                         ;sign extend [s3,s2] to form [s9,s8,s3,s2]
 0D8  12380                      TEST s3, 80                         ;test sign of first operand
 0D9  350DB                      JUMP Z, m16s_pos[0DB]
 0DA  008FF                      LOAD s8, FF
 0DB  01980            m16s_pos: LOAD s9, s8                         ;[s9,s8,s3,s2]=0000xxxx or FFFFxxxx as required
 0DC  00A0F                      LOAD sA, 0F                         ;15 positive shift and add operations to perform
 0DD  2010E           m16s_loop: SR0 s1                              ;shift right operand [s1,s0]
 0DE  20008                      SRA s0
 0DF  35CE4                      JUMP NC, m16s_noadd[0E4]            ;test for a '1'
 0E0  19420                      ADD s4, s2                          ;32-bit addition [s7,s6,s5,s4]=[s7,s6,s5,s4]+[s9,s8,s3,s2]
 0E1  1B530                      ADDCY s5, s3
 0E2  1B680                      ADDCY s6, s8
 0E3  1B790                      ADDCY s7, s9
 0E4  20206          m16s_noadd: SL0 s2                              ;multiply first operand by 2
 0E5  20300                      SLA s3
 0E6  20800                      SLA s8
 0E7  20900                      SLA s9
 0E8  1CA01                      SUB sA, 01
 0E9  354DD                      JUMP NZ, m16s_loop[0DD]             ;move to next unsigned bit
 0EA  12001                      TEST s0, 01                         ;test sign bit of operand [s1,s0]
 0EB  35CF0                      JUMP NC, m16s_nosub[0F0]
 0EC  1D420                      SUB s4, s2                          ;32-bit subtraction [s7,s6,s5,s4]=[s7,s6,s5,s4]-[s9,s8,s3,s2]
 0ED  1F530                      SUBCY s5, s3
 0EE  1F680                      SUBCY s6, s8
 0EF  1F790                      SUBCY s7, s9
 0F0  2A000          m16s_nosub: RETURN
 0F1                             ;
 0F1                             ;
 0F1                             ;
 0F1                             ;**************************************************************************************
 0F1                             ;16-bit positive integer to 5 digit decimal conversion
 0F1                             ;**************************************************************************************
 0F1                             ;
 0F1                             ;Convert the 16 bit value in register set [s7,s6]
 0F1                             ;into the BCD decimal equivalent located in the scratch pad memory
 0F1                             ;locations 'decimal0' to 'decimal4' which must be in ascending locations.
 0F1                             ;
 0F1                             ;Register set [s9,s8,s7,s6] are preserved.
 0F1                             ;
 0F1                             ;
 0F1                             ;Each digit is formed in turn starting with the least significant.
 0F1                             ;
 0F1                             ;Registers used s0,s1,s2,s3,s4,s5,s6,s7,s8
 0F1                             ;
 0F1  00005    integer16_to_BCD: LOAD s0, 05                         ;5 digits to be formed from value up to 65535
 0F2  00807                      LOAD s8, decimal0[07]               ;pointer for LS-Digit
 0F3  300F9     int_to_BCD_loop: CALL divide_16bit_by_10[0F9]        ;[s7,s6]=[s7,s6]/10  with remainder in s4
 0F4  2F480                      STORE s4, (s8)                      ;remainder becomes digit value
 0F5  18801                      ADD s8, 01                          ;move to next most significant digit
 0F6  1C001                      SUB s0, 01                          ;one less digit to compute
 0F7  354F3                      JUMP NZ, int_to_BCD_loop[0F3]
 0F8  2A000                      RETURN
 0F9                             ;
 0F9                             ;Divide 16-bit binary integer by 10
 0F9                             ;
 0F9                             ;The value to be divided is held in register set [s7,s6]
 0F9                             ;and this is where the result is returned to.
 0F9                             ;
 0F9                             ;At then end of the integer division the remainder in the range 0 to 9
 0F9                             ;will be in register s4.
 0F9                             ;
 0F9                             ;Registers used s1,s2,s3,s4,s5,s6,s7
 0F9                             ;Other registers are used but are preserved
 0F9                             ;
 0F9  01460  divide_16bit_by_10: LOAD s4, s6                         ;copy input value to [s5,s4]
 0FA  01570                      LOAD s5, s7
 0FB  00600                      LOAD s6, 00                         ;clear result
 0FC  00700                      LOAD s7, 00
 0FD  00200                      LOAD s2, 00                         ;initialise '10' value into msb's of set [s3,s2]
 0FE  003A0                      LOAD s3, A0
 0FF  0010D                      LOAD s1, 0D                         ;13 subtract and shift iterations to be performed
 100  1D420          div10_loop: SUB s4, s2                          ;perform 16-bit subtract [s5,s4]-[s3,s2]
 101  1F530                      SUBCY s5, s3
 102  35905                      JUMP C, div10_restore[105]
 103  20607                      SL1 s6                              ;shift '1' into result because subtract was possible
 104  34108                      JUMP div10_shifts[108]
 105  19420       div10_restore: ADD s4, s2                          ;perform 32-bit addition [s5,s4]+[s3,s2]
 106  1B530                      ADDCY s5, s3                        ;to restore value
 107  20606                      SL0 s6                              ;shift '0' into result because subtract was not possible
 108  20700        div10_shifts: SLA s7                              ;complete 16-bit shift left
 109  2030E                      SR0 s3                              ;divide '10' value by 2 (shift right 1 place)
 10A  20208                      SRA s2
 10B  1C101                      SUB s1, 01                          ;count iterations
 10C  35500                      JUMP NZ, div10_loop[100]
 10D  2A000                      RETURN
 10E                             ;
 10E                             ;
 10E                             ;**************************************************************************************
 10E                             ;SPI communication routines for Spartan-3E Starter Kit
 10E                             ;**************************************************************************************
 10E                             ;
 10E                             ;These routines will work with two output ports and one input port which should be
 10E                             ;defined as follows using CONSTANT directives.
 10E                             ;   (replace 'pp' with appropriate port address in each case)
 10E                             ;In the list of CONSTANT directives, there are ports associated with all the SPI devices
 10E                             ;provided on the board. Even if some devices are not used, it is vital that the remaining
 10E                             ;devices are disabled. Leaving all signals connected and use of these routines will ensure
 10E                             ;that all other devices are disabled when communicating with a particular device.
 10E                             ;
 10E                             ;
 10E                             ;
 10E                             ;CONSTANT SPI_control_port, pp       ;SPI clock and chip selects
 10E                             ;CONSTANT SPI_sck, 01                ;                  SCK - bit0
 10E                             ;CONSTANT SPI_rom_cs, 02             ;    serial rom select - bit1
 10E                             ;CONSTANT SPI_spare_control, 04      ;                spare - bit2
 10E                             ;CONSTANT SPI_amp_cs, 08             ;     amplifier select - bit3
 10E                             ;CONSTANT SPI_adc_conv, 10           ;          A/D convert - bit4
 10E                             ;CONSTANT SPI_dac_cs, 20             ;           D/A select - bit5
 10E                             ;CONSTANT SPI_amp_shdn, 40           ;       amplifier SHDN - bit6
 10E                             ;CONSTANT SPI_dac_clr, 80            ;            D/A clear - bit7
 10E                             ;
 10E                             ;CONSTANT SPI_output_port, pp        ;SPI data output
 10E                             ;CONSTANT SPI_sdo, 80                ;   SDO - bit7
 10E                             ;
 10E                             ;CONSTANT SPI_input_port, pp         ;SPI data input
 10E                             ;CONSTANT SPI_sdi, 80                ;             SDI - bit7
 10E                             ;CONSTANT SPI_amp_sdi, 40            ;   amplifier SDI - bit6
 10E                             ;
 10E                             ;
 10E                             ;
 10E                             ;
 10E                             ;Initialise SPI bus
 10E                             ;
 10E                             ;This routine should be used to initialise the SPI bus.
 10E                             ;The SCK clock is made low.
 10E                             ;Device selections are made inactive as follows
 10E                             ;   SPI_sck      = 0      Clock is Low (required)
 10E                             ;   SPI_rom_cs   = 1      Deselect ROM
 10E                             ;   spare        = 1      spare control bit
 10E                             ;   SPI_amp_cs   = 1      Deselect amplifier
 10E                             ;   SPI_adc_conv = 0      A/D convert ready to apply positive pulse
 10E                             ;   SPI_dac_cs   = 1      Deselect D/A
 10E                             ;   SPI_amp_shdn = 0      Amplifier active and available
 10E                             ;   SPI_dac_clr  = 1      D/A clear off
 10E                             ;
 10E  000AE            SPI_init: LOAD s0, AE                         ;normally AE
 10F  2C008                      OUTPUT s0, SPI_control_port[08]
 110  2A000                      RETURN
 111                             ;
 111                             ;
 111                             ;
 111                             ;
 111                             ;**************************************************************************************
 111                             ;SPI communication routines for Programmable Amplifier
 111                             ;**************************************************************************************
 111                             ;
 111                             ;
 111                             ;Set the A and B channel gain of the Dual Amplifier (LTC6912-1).
 111                             ;
 111                             ;The gain value should be provided in the s2 register with the upper nibble
 111                             ;defining the gain for the B channel and lower nibble the gain for the A channel.
 111                             ; 0000 = 0 hex = Gain  0 with input hi-Z and output driving
 111                             ; 0001 = 1 hex = Gain -1
 111                             ; 0010 = 2 hex = Gain -2
 111                             ; 0011 = 3 hex = Gain -5
 111                             ; 0100 = 4 hex = Gain -10
 111                             ; 0101 = 5 hex = Gain -20
 111                             ; 0110 = 6 hex = Gain -50
 111                             ; 0111 = 7 hex = Gain -100
 111                             ; 1000 = 8 hex = software shutdown (power on default). Hi-Z output.
 111                             ;
 111                             ;On return, the s2, register will contain the response from the LTC6912-1 amplifier.
 111                             ;This will be the same format and indicate the previous setting of the amplifier.
 111                             ;The response is obtained from the dedicated AMP_SDI signal since the LTC6912 output
 111                             ;is always active and can not be on a shared SPI bus.
 111                             ;
 111  3010E             set_amp: CALL SPI_init[10E]                  ;ensure known state of bus and s0 register
 112  0E008                      XOR s0, SPI_amp_cs[08]              ;select low on Amplifier chip select
 113  2C008                      OUTPUT s0, SPI_control_port[08]
 114  00108                      LOAD s1, 08                         ;8-bits to transmit and receive
 115  2C204    next_amp_SPI_bit: OUTPUT s2, SPI_output_port[04]      ;output data bit
 116  0E001                      XOR s0, SPI_sck[01]                 ;clock High (bit0)
 117  2C008                      OUTPUT s0, SPI_control_port[08]     ;drive clock High
 118  04301                      INPUT s3, SPI_input_port[01]        ;read input bit
 119  12340                      TEST s3, SPI_amp_sdi[40]            ;detect state of received bit
 11A  20200                      SLA s2                              ;shift new data into result and move to next transmit bit
 11B  0E001                      XOR s0, SPI_sck[01]                 ;clock Low (bit0)
 11C  2C008                      OUTPUT s0, SPI_control_port[08]     ;drive clock Low
 11D  1C101                      SUB s1, 01                          ;count bits
 11E  35515                      JUMP NZ, next_amp_SPI_bit[115]      ;repeat until finished
 11F  0E008                      XOR s0, SPI_amp_cs[08]              ;deselect the amplifier
 120  2C008                      OUTPUT s0, SPI_control_port[08]
 121  2A000                      RETURN
 122                             ;
 122                             ;
 122                             ;
 122                             ;**************************************************************************************
 122                             ;SPI communication routines for A/D Converter
 122                             ;**************************************************************************************
 122                             ;
 122                             ;
 122                             ;
 122                             ;Sample A/D converter (LTC1407A-1) and return results.
 122                             ;
 122                             ;Note there is a latency of one read to obtain the value. Each read results in the
 122                             ;the analogue inputs being sampled and converted but this value will only be transmitted
 122                             ;during the next read and conversion cycle.
 122                             ;
 122                             ;The results are returned as follows.
 122                             ;   Channel 0 in registers [s9,s8]
 122                             ;   Channel 1 in registers [s7,s6]
 122                             ;Where each is a 14-bit twos complement value sign extended to 16-bits.
 122                             ;
 122                             ;Each 14-bit value represents the analogue voltage in the range -1.25v to +1.25v
 122                             ;relative to the reference voltage of 1.65v (3.3v/2). Hence the actual input voltage
 122                             ;range is 0.4v to 2.9v. Since the input to the A/D is supplied via the programmable
 122                             ;amplifier, the VINA and VINB inputs are inverted and may cover a smaller range if                       ;
 122                             ;desired.
 122                             ;
 122                             ;Examples
 122                             ;   VINA = 0.65v with gain=-1 means input to A/D = 2.65v
 122                             ;      This is equivalent to +1.00v which is value (8192/1.25)*1 = 6553 (1999 hex)
 122                             ;
 122                             ;   VINA = 2.65v with gain=-1 means input to A/D = 0.65v
 122                             ;      This is equivalent to -1.00v which is value (2048/1.25)*-1 = -6553 (E667 hex)
 122                             ;
 122                             ;
 122                             ;Although the A/D converter claims to be an SPI device, it really
 122                             ;does not conform to the normal specification of the 4-wire interface.
 122                             ;
 122                             ;Firstly the CONV signal is only pulsed High and does not behave like
 122                             ;a normal active low select signal. Secondly, the communication is
 122                             ;34 bits which does not fit a byte boundary, and thirdly, the data output
 122                             ;to its SDO pin changes as a result of rising edges of SCK clock which
 122                             ;is not the same as the falling edge used by other devices.
 122                             ;
 122  3010E            adc_read: CALL SPI_init[10E]                  ;ensure known state of bus and s0 register
 123  0E010                      XOR s0, SPI_adc_conv[10]            ;Pulse AD-CONV High to take sample and start
 124  2C008                      OUTPUT s0, SPI_control_port[08]     ;  conversion and transmission of data.
 125  0E010                      XOR s0, SPI_adc_conv[10]            ;AD-CONV Low
 126  2C008                      OUTPUT s0, SPI_control_port[08]
 127  00122                      LOAD s1, 22                         ;34 clocks to read all data
 128  0E001        next_adc_bit: XOR s0, SPI_sck[01]                 ;clock High (bit0)
 129  2C008                      OUTPUT s0, SPI_control_port[08]     ;drive clock High
 12A  0E001                      XOR s0, SPI_sck[01]                 ;clock Low (bit0)
 12B  2C008                      OUTPUT s0, SPI_control_port[08]     ;drive clock Low
 12C  04301                      INPUT s3, SPI_input_port[01]        ;read input bit
 12D  12380                      TEST s3, SPI_sdi[80]                ;detect state of received bit
 12E  20600                      SLA s6                              ;shift new data into result registers
 12F  20700                      SLA s7
 130  20800                      SLA s8
 131  20900                      SLA s9
 132  1C101                      SUB s1, 01                          ;count bits
 133  35528                      JUMP NZ, next_adc_bit[128]          ;repeat until finished
 134  2090A                      SRX s9                              ;sign extend 14-bit result in [s9,s8]
 135  20808                      SRA s8
 136  2090A                      SRX s9
 137  20808                      SRA s8
 138  2070A                      SRX s7                              ;sign extend 14-bit result in [s7,s6]
 139  20608                      SRA s6
 13A  2070A                      SRX s7
 13B  20608                      SRA s6
 13C  2A000                      RETURN
 13D                             ;
 13D                             ;
 13D                             ;;;;;;;;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;;;;;;;;
 13D                             ;;;;;;;;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;;;;;;;;
 13D                             ;;;;;;;;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;;;;;;;;
 13D                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 13D                             ;
 13D                             ;D/A related: Send and receive one byte to and from the SPI D/A converter.
 13D                             ;
 13D                             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 13D                             ;The data supplied in register 's2' is transmitted to the SPI bus and
 13D                             ;at the same time the received byte is used to replace the value in 's2'.
 13D                             ;The SCK clock is generated by software and results in a communication rate of
 13D                             ;2.5Mbit/s with a 50MHz clock.
 13D                             ;
 13D                             ;Note that you must have previously selected the required device on the bus
 13D                             ;before attempting communication and you must subsequently deselect the device
 13D                             ;when appropriate.
 13D                             ;
 13D                             ;Entry to this routine assumes that register s0 defines the state of the SPI
 13D                             ;control signals including SCK which should be Low. The easiest way to achieve this is
 13D                             ;to use the SPI_init routine before calling this one for the first time.
 13D                             ;
 13D                             ;As a 'master' the signal sequence is as follows..
 13D                             ;   Transmit data bit on SDO line
 13D                             ;   Drive SCK transition from low to high
 13D                             ;   Receive data bit from SDI line (D/A transmits on previous falling edge)
 13D                             ;   Drive SCK transition from high to low.
 13D                             ;
 13D                             ;Important note
 13D                             ;   The received data bit must be captured some time before SCK goes low.
 13D                             ;   However the combination of relatively slow clock to output time of the
 13D                             ;   LTC2624 combined with the low drive strength of its SDO output means that
 13D                             ;   the received bit needs maximum time to settle. Therefore this routine
 13D                             ;   schedules the read as late as it can.
 13D                             ;
 13D  00108       SPI_dac_tx_rx: LOAD s1, 08                         ;8-bits to transmit and receive
 13E  2C204    next_SPI_dac_bit: OUTPUT s2, SPI_output_port[04]      ;output data bit ready to be used on rising edge
 13F  0E001                      XOR s0, SPI_sck[01]                 ;clock High (bit0)
 140  2C008                      OUTPUT s0, SPI_control_port[08]     ;drive clock High
 141  0E001                      XOR s0, SPI_sck[01]                 ;prepare clock Low (bit0)
 142  04301                      INPUT s3, SPI_input_port[01]        ;read input bit
 143  12380                      TEST s3, SPI_sdi[80]                ;detect state of received bit
 144  20200                      SLA s2                              ;shift new data into result and move to next transmit bit
 145  2C008                      OUTPUT s0, SPI_control_port[08]     ;drive clock Low
 146  1C101                      SUB s1, 01                          ;count bits
 147  3553E                      JUMP NZ, next_SPI_dac_bit[13E]      ;repeat until finished
 148  2A000                      RETURN
 149                             ;
 149                             ;
 149                             ;
 149                             ;Set a voltage on one of the LTC2624 D/A converter outputs
 149                             ;
 149                             ;The D/A converter has 4 channels. Specify which channel is to be set using
 149                             ;register sC as follows....
 149                             ;   sC     Channel                 Nominal Voltage Range
 149                             ;   00        A                       0 to 3.30v (or VREFAB)
 149                             ;   01        B                       0 to 3.30v (or VREFAB)
 149                             ;   02        C                       0 to 2.50v (or VREFCD)
 149                             ;   03        D                       0 to 2.50v (or VREFCD)
 149                             ;   0F        All channels            various as above.
 149                             ;
 149                             ;The analogue level is a 12-bit value to be supplied in lower 12-bits of register
 149                             ;pair [sB,sA]. If this value is called 'k' and is in the range 0 to 4095 (000 to FFF)
 149                             ;then
 149                             ;      Vout = (k/4096) * VREFx
 149                             ;Hence it is not possible to reach the absolute level of the reference.
 149                             ;
 149                             ;Here are some useful values..
 149                             ;    Voltage    A or B    C or D
 149                             ;      0.0       000       000
 149                             ;      0.5       26D       333
 149                             ;      0.65      327               A/D reference -1.00v
 149                             ;      1.0       4D9       666
 149                             ;      1.5       746       99A
 149                             ;      1.65      800       A8F     converter reference = 3.3/2 = 1.65v
 149                             ;      2.0       9B2       CCD
 149                             ;      2.5       C1F       FFF
 149                             ;      2.65      CD9               A/D reference +1.00v
 149                             ;      3.0       E8C       n/a
 149                             ;      3.3       FFF       n/a
 149                             ;
 149                             ;Note that the full scale deflection of FFF will result in different output
 149                             ;voltages due to different reference voltages for each pair of channels.
 149                             ;
 149                             ;SPI communication with the DAC only requires a 24-bit word to be transmitted.
 149                             ;However, the device internally contains a 32-bit shift register. When writing
 149                             ;a command word, the previous contents are shifted out and can be observed by
 149                             ;the master (Spartan-3E in this case). If you do not use a 32-bit format, then
 149                             ;the read back is confusing. Hence this routine uses a 32-bit format by transmitting
 149                             ;a dummy byte first.
 149                             ;
 149                             ;  Byte 1 = 00   8 dummy bits
 149                             ;  Byte 2 = 3c   Command nibble (3=write and update) and channel selection
 149                             ;  Byte 3 = dd   Upper 8-bits of the 12-bit voltage value
 149                             ;  Byte 4 = d0   lower 4-bits of the 12-bit voltage value and 4 dummy bits.
 149                             ;
 149                             ;At the end of this communication, the register set [s9,s8,s7,s6] will contain the
 149                             ;data received back from the D/A converter which should be the previous command.
 149                             ;
 149  3010E             set_dac: CALL SPI_init[10E]                  ;ensure known state of bus and s0 register
 14A  0E020                      XOR s0, SPI_dac_cs[20]              ;select low on D/A converter
 14B  2C008                      OUTPUT s0, SPI_control_port[08]
 14C  00200                      LOAD s2, 00                         ;Write dummy byte to DAC
 14D  3013D                      CALL SPI_dac_tx_rx[13D]
 14E  01920                      LOAD s9, s2                         ;capture response
 14F  012C0                      LOAD s2, sC                         ;Select channel for update
 150  0A20F                      AND s2, 0F                          ;isolate channel bits to be certain of correct command
 151  0C230                      OR s2, 30                           ;Use immediate Write and Update command is "0011"
 152  3013D                      CALL SPI_dac_tx_rx[13D]
 153  01820                      LOAD s8, s2                         ;capture response
 154  20A06                      SL0 sA                              ;data shift bits into correct position
 155  20B00                      SLA sB                              ;with 4 dummy bits ('0') in the least significant bits.
 156  20A06                      SL0 sA
 157  20B00                      SLA sB
 158  20A06                      SL0 sA
 159  20B00                      SLA sB
 15A  20A06                      SL0 sA
 15B  20B00                      SLA sB
 15C  012B0                      LOAD s2, sB                         ;Write 12 bit value followed by 4 dummy bits
 15D  3013D                      CALL SPI_dac_tx_rx[13D]
 15E  01720                      LOAD s7, s2                         ;capture response
 15F  012A0                      LOAD s2, sA
 160  3013D                      CALL SPI_dac_tx_rx[13D]
 161  01620                      LOAD s6, s2                         ;capture response
 162  0E020                      XOR s0, SPI_dac_cs[20]              ;deselect the D/A converter to execute
 163  2C008                      OUTPUT s0, SPI_control_port[08]
 164  2A000                      RETURN
 165                             ;
 165                             ;Perform a hard reset of the D/A converter
 165                             ;
 165  3010E           dac_reset: CALL SPI_init[10E]                  ;ensure known state of bus and s0 register
 166  0E080                      XOR s0, SPI_dac_clr[80]             ;pulse the clear signal.
 167  2C008                      OUTPUT s0, SPI_control_port[08]
 168  0E080                      XOR s0, SPI_dac_clr[80]
 169  2C008                      OUTPUT s0, SPI_control_port[08]
 16A  2A000                      RETURN
 16B                             ;
 16B                             ;
 16B                             ;**************************************************************************************
 16B                             ;LCD text messages
 16B                             ;**************************************************************************************
 16B                             ;
 16B                             ;
 16B                             ;Display 'PicoBlaze' on LCD at current cursor position
 16B                             ;
 16B                             ;
 16B  00550      disp_PicoBlaze: LOAD s5, character_P[50]
 16C  301EE                      CALL LCD_write_data[1EE]
 16D  00569                      LOAD s5, character_i[69]
 16E  301EE                      CALL LCD_write_data[1EE]
 16F  00563                      LOAD s5, character_c[63]
 170  301EE                      CALL LCD_write_data[1EE]
 171  0056F                      LOAD s5, character_o[6F]
 172  301EE                      CALL LCD_write_data[1EE]
 173  00542                      LOAD s5, character_B[42]
 174  301EE                      CALL LCD_write_data[1EE]
 175  0056C                      LOAD s5, character_l[6C]
 176  301EE                      CALL LCD_write_data[1EE]
 177  00561                      LOAD s5, character_a[61]
 178  301EE                      CALL LCD_write_data[1EE]
 179  0057A                      LOAD s5, character_z[7A]
 17A  301EE                      CALL LCD_write_data[1EE]
 17B  00565                      LOAD s5, character_e[65]
 17C  301EE                      CALL LCD_write_data[1EE]
 17D  2A000                      RETURN
 17E                             ;
 17E                             ;
 17E                             ;Display 'ADC Control' on LCD at current cursor position
 17E                             ;
 17E                             ;
 17E  00541    disp_ADC_Control: LOAD s5, character_A[41]
 17F  301EE                      CALL LCD_write_data[1EE]
 180  00544                      LOAD s5, character_D[44]
 181  301EE                      CALL LCD_write_data[1EE]
 182  00543                      LOAD s5, character_C[43]
 183  301EE                      CALL LCD_write_data[1EE]
 184  00520                      LOAD s5, character_space[20]
 185  301EE                      CALL LCD_write_data[1EE]
 186  00543                      LOAD s5, character_C[43]
 187  301EE                      CALL LCD_write_data[1EE]
 188  0056F                      LOAD s5, character_o[6F]
 189  301EE                      CALL LCD_write_data[1EE]
 18A  0056E                      LOAD s5, character_n[6E]
 18B  301EE                      CALL LCD_write_data[1EE]
 18C  00574                      LOAD s5, character_t[74]
 18D  301EE                      CALL LCD_write_data[1EE]
 18E  00572                      LOAD s5, character_r[72]
 18F  301EE                      CALL LCD_write_data[1EE]
 190  0056F                      LOAD s5, character_o[6F]
 191  301EE                      CALL LCD_write_data[1EE]
 192  0056C                      LOAD s5, character_l[6C]
 193  301EE                      CALL LCD_write_data[1EE]
 194  2A000                      RETURN
 195                             ;
 195                             ;
 195                             ;Display 'VA=' on LCD at current cursor position
 195                             ;
 195                             ;
 195  00556             disp_VA: LOAD s5, character_V[56]
 196  301EE                      CALL LCD_write_data[1EE]
 197  00541                      LOAD s5, character_A[41]
 198  301EE                      CALL LCD_write_data[1EE]
 199  0053D                      LOAD s5, character_equals[3D]
 19A  301EE                      CALL LCD_write_data[1EE]
 19B  2A000                      RETURN
 19C                             ;
 19C                             ;
 19C                             ;Display 'A/D' on LCD at current cursor position
 19C                             ;
 19C                             ;
 19C  00541             disp_AD: LOAD s5, character_A[41]
 19D  301EE                      CALL LCD_write_data[1EE]
 19E  0052F                      LOAD s5, character_divide[2F]
 19F  301EE                      CALL LCD_write_data[1EE]
 1A0  00544                      LOAD s5, character_D[44]
 1A1  301EE                      CALL LCD_write_data[1EE]
 1A2  0053D                      LOAD s5, character_equals[3D]
 1A3  301EE                      CALL LCD_write_data[1EE]
 1A4  2A000                      RETURN
 1A5                             ;
 1A5                             ;
 1A5                             ;
 1A5                             ;**************************************************************************************
 1A5                             ;Value to ASCII Conversions and LCD display
 1A5                             ;**************************************************************************************
 1A5                             ;
 1A5                             ;Convert hexadecimal value provided in register s0 into ASCII characters
 1A5                             ;
 1A5                             ;The value provided must can be any value in the range 00 to FF and will be converted into
 1A5                             ;two ASCII characters.
 1A5                             ;     The upper nibble will be represented by an ASCII character returned in register s2.
 1A5                             ;     The lower nibble will be represented by an ASCII character returned in register s1.
 1A5                             ;
 1A5                             ;The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
 1A5                             ;added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
 1A5                             ;hexadecimal requiring a further addition of 07 to the 30 already added.
 1A5                             ;
 1A5                             ;Registers used s0, s1 and s2.
 1A5                             ;
 1A5  01100   hex_byte_to_ASCII: LOAD s1, s0                         ;remember value supplied
 1A6  2000E                      SR0 s0                              ;isolate upper nibble
 1A7  2000E                      SR0 s0
 1A8  2000E                      SR0 s0
 1A9  2000E                      SR0 s0
 1AA  301B1                      CALL hex_to_ASCII[1B1]              ;convert
 1AB  01200                      LOAD s2, s0                         ;upper nibble value in s2
 1AC  01010                      LOAD s0, s1                         ;restore complete value
 1AD  0A00F                      AND s0, 0F                          ;isolate lower nibble
 1AE  301B1                      CALL hex_to_ASCII[1B1]              ;convert
 1AF  01100                      LOAD s1, s0                         ;lower nibble value in s1
 1B0  2A000                      RETURN
 1B1                             ;
 1B1                             ;Convert hexadecimal value provided in register s0 into ASCII character
 1B1                             ;
 1B1                             ;Register used s0
 1B1                             ;
 1B1  1C00A        hex_to_ASCII: SUB s0, 0A                          ;test if value is in range 0 to 9
 1B2  359B4                      JUMP C, number_char[1B4]
 1B3  18007                      ADD s0, 07                          ;ASCII char A to F in range 41 to 46
 1B4  1803A         number_char: ADD s0, 3A                          ;ASCII char 0 to 9 in range 30 to 40
 1B5  2A000                      RETURN
 1B6                             ;
 1B6                             ;
 1B6                             ;Display the two character HEX value of the register contents 's0' on
 1B6                             ;the LCD display at the current cursor position.
 1B6                             ;
 1B6                             ;Registers used s0, s1, s2, s4, s5, s6
 1B6                             ;
 1B6  301A5       disp_hex_byte: CALL hex_byte_to_ASCII[1A5]
 1B7  01610                      LOAD s6, s1                         ;remember lower hex character
 1B8  01520                      LOAD s5, s2                         ;display upper hex character
 1B9  301EE                      CALL LCD_write_data[1EE]
 1BA  01560                      LOAD s5, s6                         ;display lower hex character
 1BB  301EE                      CALL LCD_write_data[1EE]
 1BC  2A000                      RETURN
 1BD                             ;
 1BD                             ;
 1BD                             ;**************************************************************************************
 1BD                             ;Software delay routines
 1BD                             ;**************************************************************************************
 1BD                             ;
 1BD                             ;
 1BD                             ;
 1BD                             ;Delay of 1us.
 1BD                             ;
 1BD                             ;Constant value defines reflects the clock applied to KCPSM3. Every instruction
 1BD                             ;executes in 2 clock cycles making the calculation highly predictable. The '6' in
 1BD                             ;the following equation even allows for 'CALL delay_1us' instruction in the initiating code.
 1BD                             ;
 1BD                             ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
 1BD                             ;
 1BD                             ;Registers used s0
 1BD                             ;
 1BD  0000B           delay_1us: LOAD s0, delay_1us_constant[0B]
 1BE  1C001            wait_1us: SUB s0, 01
 1BF  355BE                      JUMP NZ, wait_1us[1BE]
 1C0  2A000                      RETURN
 1C1                             ;
 1C1                             ;Delay of 40us.
 1C1                             ;
 1C1                             ;Registers used s0, s1
 1C1                             ;
 1C1  00128          delay_40us: LOAD s1, 28                         ;40 x 1us = 40us
 1C2  301BD           wait_40us: CALL delay_1us[1BD]
 1C3  1C101                      SUB s1, 01
 1C4  355C2                      JUMP NZ, wait_40us[1C2]
 1C5  2A000                      RETURN
 1C6                             ;
 1C6                             ;
 1C6                             ;Delay of 1ms.
 1C6                             ;
 1C6                             ;Registers used s0, s1, s2
 1C6                             ;
 1C6  00219           delay_1ms: LOAD s2, 19                         ;25 x 40us = 1ms
 1C7  301C1            wait_1ms: CALL delay_40us[1C1]
 1C8  1C201                      SUB s2, 01
 1C9  355C7                      JUMP NZ, wait_1ms[1C7]
 1CA  2A000                      RETURN
 1CB                             ;
 1CB                             ;Delay of 20ms.
 1CB                             ;
 1CB                             ;Delay of 20ms used during initialisation.
 1CB                             ;
 1CB                             ;Registers used s0, s1, s2, s3
 1CB                             ;
 1CB  00314          delay_20ms: LOAD s3, 14                         ;20 x 1ms = 20ms
 1CC  301C6           wait_20ms: CALL delay_1ms[1C6]
 1CD  1C301                      SUB s3, 01
 1CE  355CC                      JUMP NZ, wait_20ms[1CC]
 1CF  2A000                      RETURN
 1D0                             ;
 1D0                             ;Delay of approximately 1 second.
 1D0                             ;
 1D0                             ;Registers used s0, s1, s2, s3, s4
 1D0                             ;
 1D0  00432            delay_1s: LOAD s4, 32                         ;50 x 20ms = 1000ms
 1D1  301CB             wait_1s: CALL delay_20ms[1CB]
 1D2  1C401                      SUB s4, 01
 1D3  355D1                      JUMP NZ, wait_1s[1D1]
 1D4  2A000                      RETURN
 1D5                             ;
 1D5                             ;
 1D5                             ;
 1D5                             ;**************************************************************************************
 1D5                             ;LCD Character Module Routines
 1D5                             ;**************************************************************************************
 1D5                             ;
 1D5                             ;LCD module is a 16 character by 2 line display but all displays are very similar
 1D5                             ;The 4-wire data interface will be used (DB4 to DB7).
 1D5                             ;
 1D5                             ;The LCD modules are relatively slow and software delay loops are used to slow down
 1D5                             ;KCPSM3 adequately for the LCD to communicate. The delay routines are provided in
 1D5                             ;a different section (see above in this case).
 1D5                             ;
 1D5                             ;
 1D5                             ;Pulse LCD enable signal 'E' high for greater than 230ns (1us is used).
 1D5                             ;
 1D5                             ;Register s4 should define the current state of the LCD output port.
 1D5                             ;
 1D5                             ;Registers used s0, s4
 1D5                             ;
 1D5  0E401         LCD_pulse_E: XOR s4, LCD_E[01]                   ;E=1
 1D6  2C440                      OUTPUT s4, LCD_output_port[40]
 1D7  301BD                      CALL delay_1us[1BD]
 1D8  0E401                      XOR s4, LCD_E[01]                   ;E=0
 1D9  2C440                      OUTPUT s4, LCD_output_port[40]
 1DA  2A000                      RETURN
 1DB                             ;
 1DB                             ;Write 4-bit instruction to LCD display.
 1DB                             ;
 1DB                             ;The 4-bit instruction should be provided in the upper 4-bits of register s4.
 1DB                             ;Note that this routine does not release the master enable but as it is only
 1DB                             ;used during initialisation and as part of the 8-bit instruction write it
 1DB                             ;should be acceptable.
 1DB                             ;
 1DB                             ;Registers used s4
 1DB                             ;
 1DB  0A4F8     LCD_write_inst4: AND s4, F8                          ;Enable=1 RS=0 Instruction, RW=0 Write, E=0
 1DC  2C440                      OUTPUT s4, LCD_output_port[40]      ;set up RS and RW >40ns before enable pulse
 1DD  301D5                      CALL LCD_pulse_E[1D5]
 1DE  2A000                      RETURN
 1DF                             ;
 1DF                             ;
 1DF                             ;Write 8-bit instruction to LCD display.
 1DF                             ;
 1DF                             ;The 8-bit instruction should be provided in register s5.
 1DF                             ;Instructions are written using the following sequence
 1DF                             ; Upper nibble
 1DF                             ; wait >1us
 1DF                             ; Lower nibble
 1DF                             ; wait >40us
 1DF                             ;
 1DF                             ;Registers used s0, s1, s4, s5
 1DF                             ;
 1DF  01450     LCD_write_inst8: LOAD s4, s5
 1E0  0A4F0                      AND s4, F0                          ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
 1E1  0C408                      OR s4, LCD_drive[08]                ;Enable=1
 1E2  301DB                      CALL LCD_write_inst4[1DB]           ;write upper nibble
 1E3  301BD                      CALL delay_1us[1BD]                 ;wait >1us
 1E4  01450                      LOAD s4, s5                         ;select lower nibble with
 1E5  20407                      SL1 s4                              ;Enable=1
 1E6  20406                      SL0 s4                              ;RS=0 Instruction
 1E7  20406                      SL0 s4                              ;RW=0 Write
 1E8  20406                      SL0 s4                              ;E=0
 1E9  301DB                      CALL LCD_write_inst4[1DB]           ;write lower nibble
 1EA  301C1                      CALL delay_40us[1C1]                ;wait >40us
 1EB  004F0                      LOAD s4, F0                         ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
 1EC  2C440                      OUTPUT s4, LCD_output_port[40]      ;Release master enable
 1ED  2A000                      RETURN
 1EE                             ;
 1EE                             ;
 1EE                             ;
 1EE                             ;Write 8-bit data to LCD display.
 1EE                             ;
 1EE                             ;The 8-bit data should be provided in register s5.
 1EE                             ;Data bytes are written using the following sequence
 1EE                             ; Upper nibble
 1EE                             ; wait >1us
 1EE                             ; Lower nibble
 1EE                             ; wait >40us
 1EE                             ;
 1EE                             ;Registers used s0, s1, s4, s5
 1EE                             ;
 1EE  01450      LCD_write_data: LOAD s4, s5
 1EF  0A4F0                      AND s4, F0                          ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
 1F0  0C40C                      OR s4, 0C                           ;Enable=1 RS=1 Data, RW=0 Write, E=0
 1F1  2C440                      OUTPUT s4, LCD_output_port[40]      ;set up RS and RW >40ns before enable pulse
 1F2  301D5                      CALL LCD_pulse_E[1D5]               ;write upper nibble
 1F3  301BD                      CALL delay_1us[1BD]                 ;wait >1us
 1F4  01450                      LOAD s4, s5                         ;select lower nibble with
 1F5  20407                      SL1 s4                              ;Enable=1
 1F6  20407                      SL1 s4                              ;RS=1 Data
 1F7  20406                      SL0 s4                              ;RW=0 Write
 1F8  20406                      SL0 s4                              ;E=0
 1F9  2C440                      OUTPUT s4, LCD_output_port[40]      ;set up RS and RW >40ns before enable pulse
 1FA  301D5                      CALL LCD_pulse_E[1D5]               ;write lower nibble
 1FB  301C1                      CALL delay_40us[1C1]                ;wait >40us
 1FC  004F0                      LOAD s4, F0                         ;Enable=0 RS=0 Instruction, RW=0 Write, E=0
 1FD  2C440                      OUTPUT s4, LCD_output_port[40]      ;Release master enable
 1FE  2A000                      RETURN
 1FF                             ;
 1FF                             ;
 1FF                             ;
 1FF                             ;
 1FF                             ;Read 8-bit data from LCD display.
 1FF                             ;
 1FF                             ;The 8-bit data will be read from the current LCD memory address
 1FF                             ;and will be returned in register s5.
 1FF                             ;It is advisable to set the LCD address (cursor position) before
 1FF                             ;using the data read for the first time otherwise the display may
 1FF                             ;generate invalid data on the first read.
 1FF                             ;
 1FF                             ;Data bytes are read using the following sequence
 1FF                             ; Upper nibble
 1FF                             ; wait >1us
 1FF                             ; Lower nibble
 1FF                             ; wait >40us
 1FF                             ;
 1FF                             ;Registers used s0, s1, s4, s5
 1FF                             ;
 1FF  0040E      LCD_read_data8: LOAD s4, 0E                         ;Enable=1 RS=1 Data, RW=1 Read, E=0
 200  2C440                      OUTPUT s4, LCD_output_port[40]      ;set up RS and RW >40ns before enable pulse
 201  0E401                      XOR s4, LCD_E[01]                   ;E=1
 202  2C440                      OUTPUT s4, LCD_output_port[40]
 203  301BD                      CALL delay_1us[1BD]                 ;wait >260ns to access data
 204  04502                      INPUT s5, LCD_input_port[02]        ;read upper nibble
 205  0E401                      XOR s4, LCD_E[01]                   ;E=0
 206  2C440                      OUTPUT s4, LCD_output_port[40]
 207  301BD                      CALL delay_1us[1BD]                 ;wait >1us
 208  0E401                      XOR s4, LCD_E[01]                   ;E=1
 209  2C440                      OUTPUT s4, LCD_output_port[40]
 20A  301BD                      CALL delay_1us[1BD]                 ;wait >260ns to access data
 20B  04002                      INPUT s0, LCD_input_port[02]        ;read lower nibble
 20C  0E401                      XOR s4, LCD_E[01]                   ;E=0
 20D  2C440                      OUTPUT s4, LCD_output_port[40]
 20E  0A5F0                      AND s5, F0                          ;merge upper and lower nibbles
 20F  2000E                      SR0 s0
 210  2000E                      SR0 s0
 211  2000E                      SR0 s0
 212  2000E                      SR0 s0
 213  0D500                      OR s5, s0
 214  00404                      LOAD s4, 04                         ;Enable=0 RS=1 Data, RW=0 Write, E=0
 215  2C440                      OUTPUT s4, LCD_output_port[40]      ;Stop reading 5V device and release master enable
 216  301C1                      CALL delay_40us[1C1]                ;wait >40us
 217  2A000                      RETURN
 218                             ;
 218                             ;
 218                             ;Reset and initialise display to communicate using 4-bit data mode
 218                             ;Includes routine to clear the display.
 218                             ;
 218                             ;Requires the 4-bit instructions 3,3,3,2 to be sent with suitable delays
 218                             ;following by the 8-bit instructions to set up the display.
 218                             ;
 218                             ;  28 = '001' Function set, '0' 4-bit mode, '1' 2-line, '0' 5x7 dot matrix, 'xx'
 218                             ;  06 = '000001' Entry mode, '1' increment, '0' no display shift
 218                             ;  0C = '00001' Display control, '1' display on, '0' cursor off, '0' cursor blink off
 218                             ;  01 = '00000001' Display clear
 218                             ;
 218                             ;Registers used s0, s1, s2, s3, s4
 218                             ;
 218  301CB           LCD_reset: CALL delay_20ms[1CB]                ;wait more that 15ms for display to be ready
 219  00430                      LOAD s4, 30
 21A  301DB                      CALL LCD_write_inst4[1DB]           ;send '3'
 21B  301CB                      CALL delay_20ms[1CB]                ;wait >4.1ms
 21C  301DB                      CALL LCD_write_inst4[1DB]           ;send '3'
 21D  301C6                      CALL delay_1ms[1C6]                 ;wait >100us
 21E  301DB                      CALL LCD_write_inst4[1DB]           ;send '3'
 21F  301C1                      CALL delay_40us[1C1]                ;wait >40us
 220  00420                      LOAD s4, 20
 221  301DB                      CALL LCD_write_inst4[1DB]           ;send '2'
 222  301C1                      CALL delay_40us[1C1]                ;wait >40us
 223  00528                      LOAD s5, 28                         ;Function set
 224  301DF                      CALL LCD_write_inst8[1DF]
 225  00506                      LOAD s5, 06                         ;Entry mode
 226  301DF                      CALL LCD_write_inst8[1DF]
 227  0050C                      LOAD s5, 0C                         ;Display control
 228  301DF                      CALL LCD_write_inst8[1DF]
 229  00501           LCD_clear: LOAD s5, 01                         ;Display clear
 22A  301DF                      CALL LCD_write_inst8[1DF]
 22B  301C6                      CALL delay_1ms[1C6]                 ;wait >1.64ms for display to clear
 22C  301C6                      CALL delay_1ms[1C6]
 22D  2A000                      RETURN
 22E                             ;
 22E                             ;Position the cursor ready for characters to be written.
 22E                             ;The display is formed of 2 lines of 16 characters and each
 22E                             ;position has a corresponding address as indicated below.
 22E                             ;
 22E                             ;                   Character position
 22E                             ;           0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
 22E                             ;
 22E                             ; Line 1 - 80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F
 22E                             ; Line 2 - C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF
 22E                             ;
 22E                             ;This routine will set the cursor position using the value provided
 22E                             ;in register s5. The upper nibble will define the line and the lower
 22E                             ;nibble the character position on the line.
 22E                             ; Example s5 = 2B will position the cursor on line 2 position 11
 22E                             ;
 22E                             ;Registers used s0, s1, s2, s3, s4
 22E                             ;
 22E  12510          LCD_cursor: TEST s5, 10                         ;test for line 1
 22F  35234                      JUMP Z, set_line2[234]
 230  0A50F                      AND s5, 0F                          ;make address in range 80 to 8F for line 1
 231  0C580                      OR s5, 80
 232  301DF                      CALL LCD_write_inst8[1DF]           ;instruction write to set cursor
 233  2A000                      RETURN
 234  0A50F           set_line2: AND s5, 0F                          ;make address in range C0 to CF for line 2
 235  0C5C0                      OR s5, C0
 236  301DF                      CALL LCD_write_inst8[1DF]           ;instruction write to set cursor
 237  2A000                      RETURN
 238                             ;
 238                             ;
 238                             ;**************************************************************************************
 238                             ;Interrupt Service Routine (ISR)
 238                             ;**************************************************************************************
 238                             ;
 238                             ;Interrupts occur at 1 second intervals.
 238                             ;;;;;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;;;;;;;;;;
 238                             ; HAVE TO CHANGE FROM 1Hz to XYZkHz.
 238                             ;;;;;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;;;;;;;;;;
 238                             ;;;;;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;;;;;;;;;;
 238                             ;;;;;;;;;;;;;;;;;;;thejas;;;;;;;;;;;;;;;;;;;;;;;;;;;
 238                             ;
 238                             ;
 238                             ;Each interrupt is used to take analogue samples and store them in scratch pad memory.
 238                             ;The interrupt clears a 'flag' in register sF so that the main program can advance.
 238                             ;
 238                             ;Each interrupt is the fundamental timing trigger used to set the sample rate and
 238                             ;it is therefore use to set the D/A outputs by copying the values stored in
 238                             ;scratch pad memory and outputting them to the D/A converter using the SPI bus.
 238                             ;
 238                             ;Because the SPI communication is in itself a predictable process, the sample rate
 238                             ;is preserved without sample jitter. All variable activities are left to the main
 238                             ;program.
 238                             ;
 238                             ;Each time PicoBlaze transmits a 32-bit command word to the D/A converter, the
 238                             ;D/A responds with the last command it was sent. So as the end of this service routine
 238                             ;the register set [s9,s8,s7,s6] will contain the command which has just been sent
 238                             ;for the setting of channel C.
 238                             ;
 238  30122                 ISR: CALL adc_read[122]                  ;read A/D Converter
 239  2E800                      STORE s8, ADC0_lsb[00]              ;store ADC Channel 0
 23A  2E901                      STORE s9, ADC0_msb[01]
 23B  2E602                      STORE s6, ADC1_lsb[02]              ;store ADC Channel 1
 23C  2E703                      STORE s7, ADC1_msb[03]
 23D  2C880                      OUTPUT s8, LED_port[80]
 23E  2C980                      OUTPUT s9, LED_port[80]             ;theja: sending to the wrapper verilog
 23F                             ;
 23F  00F00                      LOAD sF, 00                         ;clear flag
 240  38001                      RETURNI ENABLE
 241                             ;
 241                             ;
 241                             ;**************************************************************************************
 241                             ;Interrupt Vector
 241                             ;**************************************************************************************
 241                             ;
 3FF                             ADDRESS 3FF
 3FF  34238                      JUMP ISR[238]
 3FF                             ;
 3FF                             ;
